---
layout: post
title: GAMES101_notes_02
date: 2023-01-14 23:44 +0800
tags: ["Learning Notes", "GAMES101"]
toc: true
---

> GAMES101: 现代计算机图形学入门
>
> 笔记02：Shading,

## Lesson 07 Shading 1(Illumination, Shading and Graphics Pipeline)

本讲内容：

- Visibility/ occlusion
  - Z-buffering
- Shading
  - Illumination & Shading
  - Graphics Pipeline

### Visibility 可见性

#### Painter's Algorithm

受油画绘画技术的启发，作画时应当先画远处的物体，再画近处的物体，从而保证物体遮挡的结果是正确的

问题是如何判断哪个物体远，哪个物体近？相同远近的物体，绘画顺序怎么样确定？

需要首先对三角形进行排序，需要$O(n\log n)$的时间，但是不能完全解决问题

### Z-buffer 深度缓存

用于解决上述提到的问题

Idea:

- Store current min. z-value __for each sample(pixel)__
- Needs an additional buffer for depth values
  - frame buffer stores color values
  - depth buffer (z-buffer) stores depth

Important: For simplicity we suppose $z$ is always positive(smaller $z$ -> closer, larger $z$ -> further)

#### 算法流程

- Initialize depth buffer to $\infty$
- During rasterization:

```c++
    for(each triangle T)
        for(each sample(x, y, z) in T)
            if(z < zbuffer[x, y])           // closest sample so far
                framebuffer[x, y] = rgb;    // update color
                zbuffer[x, y] = z;          // update depth
            else
                ;                           // do nothing, this sample is occluded
```

（目前只是说明在已知深度的情况下如何处理遮挡关系，还未介绍如何确定物体深度）

#### 正确性和复杂度

复杂度

- 对于$n$个三角形只需要花费$O(n)$的时间
- 并不是排序算法，所以时间消耗是线性的

不同三角形处理顺序不改变结果(但是会被舍入误差影响)

Most important visibility algorithm

- Implemented in hardware for all GPUs

#### 对于MSAA的影响

当采用MSAA时，深度缓存应当是对每个采样点，而不是对每个像素进行采样

## Shading 着色

目前已经学过的内容：

- Position objects and the camera in the world 空间中的模型和摄像机
- Compute position of objects relative to the camera 计算模型位置
- Project objects onto the screen 投影
- Sample triangle coverage 光栅化

下一步的操作：着色（Shading）

### Definition of Shading

- The definition in the dictionary: The darkening or coloring of an illustration or diagram with parallel lines or a block of color.
- The definition in this course: The process of applying a material to an object.

### A Simple Shading Model(Blinn-Phong Reflectance Model)

#### Perceptual Observations

- Specular highlights 高光
- Diffuse reflection 漫反射
- Ambient lighting 环境光照

#### Shading is Local

Compute light reflected toward camera at specific __shading point__

Input:

- Viewer direction, $v$
- Surface normal, $n$
- Light direction(for each of many lights), $l$
- Surfaces parameters(colors, shininess, ...)

注意：着色并不是添加阴影！（shading $\ne$ shadow）

#### Diffuse Reflection

- Light is scattered uniformly in all directions
  - Surface color is the same for all viewing directions
- But how much light(energy) is received?
  - Lambert's cosine law：随着光线和平面法线夹角$\theta$的不断扩大，单位面积接收到的光线能量逐渐变小，比例满足$\cos \theta = l \cdot n$

#### Light Falloff 能量耗散

将光源视为一个持续释放能量的点，则随着传播距离的增加，能量的大小应当与距离的平方成反比。

#### Lambertian(Diffuse) Shading

Shading __independent__ of view direction

$$
L_d = k_d(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{l})
$$

其中

- $L_d$: diffusely reflected light
- $k_d$: diffuse coefficient (color)
- $(I/r^2)$: energy arrived at the shading point
- $\max(0, \mathbf{n}\cdot \mathbf{l})$: energy received by the shading point

## Lesson 08 Shading 2(Shading, Pipeline and Texture Mapping)

本讲内容：

- Blinn-Phong reflectance model
  - Specular and ambient terms
- Shading frequencies
- Graphics pipeline

### Blinn-Phong reflectance model

回忆上讲的漫反射项(Lambertian/Diffuse Term)，可以发现漫反射项和观测方向$v$没有关系，对任意方向的反射光强度都是相同的。

### Specular Term(Blinn-Phong)

Intensity __depends__ on view direction

- Bright near mirror reflection direction

$v$ close to mirror direction $\Leftrightarrow$ __half vector near normal__

- Measure "near" by dot product of unit vectors

引入半程向量$\mathbf{h}$，可以避免计算反射向量$r$的困难，半程向量的计算公式如下：

$$
\begin{align*}
    \mathbf{h}
    &= bisector(\mathbf{v}, \mathbf{l})\\
    &= \frac{\mathbf{v}+\mathbf{l}}{\|\mathbf{v}+\mathbf{v}\|}
\end{align*}
$$

则Blinn-Phong公式给出的镜面反射项为

$$
\begin{align*}
    L_s
    &= k_s(I/r^2)\max(0, \cos \alpha)^p\\
    &= k_s(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{h})^p
\end{align*}
$$

其中

- $L_s$: Specularly reflected light
- $k_s$: specular coefficient
- 余弦值添加指数参数$p$的原因：能够使高光得到加窄，使得只有最接近镜面反射的部分高光明显。一般$p$取$100-200$

### Ambient Term(Blinn-Phong)

Shading that does not depend on anything

- Add constant color to account for disregarded illumination and fill in black shadows
- This is approximate / fake!

环境光项计算公式如下：

$$
    L_a = k_a I_a
$$

其中

- $L_a$: Reflected ambient light
- $k_a$: Ambient coefficient

综合上述内容，可得到Blinn-Phong反射模型：

$$
\begin{align*}
    L &= L_a + L_d + L_s\\
    &= k_aI_a + k_d(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{l}) + k_s(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{h})^p
\end{align*}
$$

### Shading Frequencies 着色频率

对每个平面上多少个点进行Shading，将会影响着色的结果

三种常见的着色方式：

1. __Flat__ Shading 逐面着色
   - Triangle face is flat - one normal vector
   - Not good for smooth surfaces
2. __Gouraud__ shading 逐顶点着色
   - Interpolate colors from vertices across triangle
   - Each vertex has a normal vector(how?)
3. __Phong__ shading 逐像素着色
   - Interpolate normal vectors across each triangle
   - Compute full shading model at each pixel
   - Not the Blinn-Phong Reflectance Model

当几何体足够复杂的时候，逐面着色和逐顶点着色与逐像素着色的区别会变小。

#### Define Per-Vertex Normal Vectors

Best to get vertex normals from the underlying geometry. Otherwise have to infer vertex normal from triangle faces

- Simple scheme: __Average surrounding face normals__

$$
    N_v = \frac{\sum_i N_i}{\|\sum_iN_i\|}
$$

#### Define Per-Pixel Normal Vectors

Barycentric interpolation (introducing soon) of vertex normals.

Don't forget to normalize the interpolated directions

### Graphics(Real-time Rendering) Pipeline

管线：从Input到Output的过程：

- Input: Vertices in 3D space
- Application:
  1. Vertex Processing: Vertices positioned in screen space
  2. Triangle Processing: Triangles positioned in screen space
  3. Rasterization: Fragments(one per covered sample)
  4. Fragment Processing: Shaded fragments
  5. Framebuffer Operations: Display
- Output: images(pixels)

过去学习的内容对应到pipeline中：

- MVP transforms: 1
- Sampling triangle coverage: 3
- Z-Buffer Visibility Tests: 4
- Shading: 1, 4(考虑不同的着色频率，着色发生的环节会不同)
- Texture mapping(introducing soon): 1, 4

#### Shader Programs

- Program vertex and fragment processing stages(分别称为vertex-shader和fragment-shader/pixel-shader)
- Describe operation on a single vertex(or fragment)

Example GLSL fragment shader program

```c++
uniform sampler2D my Texture; // program parameter
uniform vec3 lightDir;        // program parameter
varying vec2 uv;              // per fragment value(interp. by rasterizer)
varying vec3 norm;            // per fragment value(interp. by rasterizer)

void(diffuseShader)()
{
  vec3 kd;
  kd = texture2d(myTexture, uv);                // material color from texture
  kd *= clamp(dot(-lightDir, norm), 0.0, 1.0);  // Lambertian shading model
  gl_FragColor = vec4(kd, 1.0);                 // Output fragment color
}
```

Remark:

- Shader function executes once per fragment;
- Outputs color of surface at the current fragment's screen sample position;
- This shader performs a texture lookup to obtain the surfaces's material color at this point, then performs a diffuse lighting calculation.

[Snail Shader Program](https://shadertoy.com/view/ld3Gz2)

#### Modern development in CG

（省略该部分内容）

### Texture Mapping

(unfinished)
