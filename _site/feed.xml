<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-01-20T01:01:21+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Zhengtong’s blog</title><subtitle>Learning and recording</subtitle><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><entry><title type="html">Computational_Geometry_notes_01</title><link href="http://localhost:4000/2023/01/14/Computational_Geometry_notes_01/" rel="alternate" type="text/html" title="Computational_Geometry_notes_01" /><published>2023-01-14T23:49:00+08:00</published><updated>2023-01-14T23:49:00+08:00</updated><id>http://localhost:4000/2023/01/14/Computational_Geometry_notes_01</id><content type="html" xml:base="http://localhost:4000/2023/01/14/Computational_Geometry_notes_01/"><![CDATA[<h2 id="chapter-09-delaunay-triangulations">Chapter 09 Delaunay Triangulations</h2>

<blockquote>
  <p>Used for height interpolation</p>
</blockquote>

<h3 id="introduction">Introduction</h3>

<h3 id="triangulations-of-planar-point-sets">Triangulations of Planar Point Sets</h3>

<h4 id="the-definition-of-triangulation">The Definition of Triangulation</h4>

<p>令$P := {p_1, p_2, \dots, p_n}$为平面上的一组点集，我们首先定义 <em>最大平面子细分(maximal planar subdivision)</em>。</p>

<p>$P$的平面子细分$\mathcal{S}$是一个平面图，顶点为$P$的所有点，边为互不相交的线段，由于$P$包含的点是有限个，自然平面子细分的边数也存在上限。我们记包含最多边的细分为最大平面子细分$\mathcal{S_0}$，此时任意一条由$P$上两点连成，且不在$\mathcal{S_0}$中的线段都与$\mathcal{S_0}$中的某条线段相交。</p>

<p>由欧拉定律，$\mathcal{S_0}$的边数$n_e$取决于$P$中的点数$n$和$P$的凸包$\mathrm{CH}(P)$中包含的点数$k$，并满足如下关系式：</p>

\[n_e = 3n - 3 - k.\]

<p>在这样的定义下，我们还可以得知：$\mathcal{S_0}$构成的平面图中，最小单位的多边形结构都是三角形（否则，必然可以添加更多线段到$\mathcal{S_0}$中，矛盾！），因此，我们也称由$P$中点生成的最大平面子细分为$P$的 <em>三角剖分(triangulation)</em>，记作$\mathcal{T}$。</p>

<p>同样，$\mathcal{T}$中包含的三角形个数$n_t$也由$P$中的点数$n$和$P$的凸包$\mathrm{CH}(P)$中包含的点数$k$确定，并满足如下关系式：</p>

\[n_t = 2n - 2 - k.\]

<h4 id="angle-optimal-triangulation">Angle-optimal Triangulation</h4>

<p>在上述定义下，我们讨论$P$的三角剖分$\mathcal{T}$的性质，假设其中包含$m$个三角形。则$\mathcal{T}$中三角形的角共有$3m$个，将其按升序排列并编号，记为$\alpha_1, \alpha_2, \dots, \alpha_{3m}$，则它们满足对任意的$1\le i &lt; j \le 3m$都有$\alpha_i \le \alpha_j$。我们定义$A(\mathcal{T}) := (\alpha_1, \alpha_2, \dots, \alpha_{3m})$为$\mathcal{T}$的 <em>角度序列(angle-vector)</em>
。</p>

<p>令$\mathcal{T’}$为$P$的另一个三角剖分，它的角度序列$A(\mathcal{T’}) := (\alpha’<em>1, \alpha’_2, \dots, \alpha’</em>{3m})$。如果存在$i$，$1\le i \le 3m$，满足</p>

\[\alpha_j = \alpha'_j,\ \forall j &lt; i,\quad \alpha_i &lt; \alpha'_i.\]

<p>我们称角度序列$A(\mathcal{T})$比$A(\mathcal{T’})$大，记为$\mathcal{T} &gt; \mathcal{T’}$。</p>

<p>如果一个$P$的三角剖分$\mathcal{T_0}$满足对$P$的任意三角剖分$\mathcal{T}$都有$A(\mathcal{T_0}) \ge \mathcal{T}$，我们就说$\mathcal{T_0}$是$P$的 <em>角度最优三角剖分(angle-optimal triangulation)</em>。</p>

<h4 id="way-to-construct-angle-optimal-triangulation">Way to Construct Angle-optimal Triangulation</h4>

<p>如果$P$的三角剖分$\mathcal{T}$中的一条边$e = \overline{p_i p_j}$满足</p>

<ul>
  <li>$e$不是$\mathrm{CH}(\mathcal{S_0})$上的边；</li>
  <li>由$e$构成的两个相邻三角形可以拼接成一个凸四边形，另外两点记为$p_l, p_k$。</li>
</ul>

<p>那么我们可以通过对$\mathcal{T}$删除$\overline{p_ip_j}$并添加$\overline{p_lp_k}$的形式获得不同于$\mathcal{T}$的新的三角剖分$\mathcal{T’}$。显然，两个三角剖分的角度序列中只有6个角发生了变化，它们从$\alpha_1, \alpha_2,\dots, \alpha_6$变成了$\alpha’_1, \alpha’_2,\dots, \alpha’_6$。如果</p>

\[\min_{1\le i \le 6} \alpha_i &lt; \min_{1\le j \le 6} \alpha'_j\]

<p>我们就称边$e = \overline{p_ip_j}$是 <em>不合规的(illegal)</em>。之前提到的“删除$\overline{p_ip_j}$并添加$\overline{p_lp_k}$”操作我们称为 <em>边翻转(edge flip)</em></p>

<p>如果一个三角剖分中不存在不合规边，那么我们就说它是 <em>合规三角剖分(legal triangulation)</em>。根据这些定义，我们可以得知角度最优三角剖分一定是合规三角剖分。</p>

<p>由于有限点集的三角剖分数量是有限的，加上不合规边可以通过边翻转操作变为合规边，因此我们可以通过不断地检查当前三角剖分是否存在不合规边，并通过边翻转操作改进，最终得到一个合规的三角剖分。具体算法如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Algorithm</span> <span class="nf">Legal_Triangulation</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="c1">// Input: Any triangulation T of a point set P</span>
<span class="c1">// Output: A legal triangulation of P</span>
    <span class="k">while</span><span class="p">(</span><span class="n">T</span> <span class="n">contains</span> <span class="n">an</span> <span class="n">illegal</span> <span class="n">edge</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">for</span><span class="p">(</span><span class="n">each</span> <span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="n">is</span> <span class="n">illegal</span><span class="p">)</span>
            <span class="n">flip</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">p_i</span><span class="p">,</span> <span class="n">p_j</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">T</span>
</code></pre></div></div>

<p>事实上，基于泰勒斯定理（见附录）及初等几何的知识，我们不需要对重复比较边翻转前后的六个角大小来判断边是否合规，这可以加速算法的过程。但是即便如此，算法的时间复杂度仍然非常大且难以估计；此外，这一方法的结果是合规的三角剖分，与我们最初问题中期待的角度最优三角剖分仍有一定差距。为了解决上述问题，人们提出了 <em>Delaunay三角剖分</em></p>

<h3 id="the-delaunay-triangulation">The Delaunay Triangulation</h3>

<h3 id="computing-the-delaunay-triangulation">Computing the Delaunay Triangulation</h3>

<h3 id="the-analysis">The Analysis</h3>

<h3 id="appendix">Appendix</h3>

<h4 id="泰勒斯定理thaless-theorem">泰勒斯定理(Thales’s Theorem):</h4>

<p>Theorem 9.2 (Thales’s Theorem): 令$C$为一个圆，$l$为与$C$相交的一条直线，两个交点分别为$a, b$。$p, q, r, s$在$l$的同一侧。假设$p, q$在$C$上，$r$在圆内，$s$在圆外，则</p>

\[\angle arb &gt; \angle apb = \angle aqb &gt; \angle asb\]

<blockquote>
  <p>注： 这里书上194页给的叙述有误，该定理并不能保证a, r, b组成的最小的角符合上述要求，而是必须是以r为顶点的角，对于其他三个角也是如此。</p>
</blockquote>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="learning" /><category term="Computational Geometry" /><summary type="html"><![CDATA[Chapter 09 Delaunay Triangulations]]></summary></entry><entry><title type="html">6.046_notes_01</title><link href="http://localhost:4000/2023/01/14/6_046_notes_01/" rel="alternate" type="text/html" title="6.046_notes_01" /><published>2023-01-14T23:44:00+08:00</published><updated>2023-01-14T23:44:00+08:00</updated><id>http://localhost:4000/2023/01/14/6_046_notes_01</id><content type="html" xml:base="http://localhost:4000/2023/01/14/6_046_notes_01/"><![CDATA[<blockquote>
  <p>6.046: Design and Analysis of Algorithms</p>

  <p>笔记01：</p>
</blockquote>

<h2 id="lesson-01-introduction--overview">Lesson 01: Introduction &amp; Overview</h2>

<ul>
  <li>课程概览</li>
  <li>不同算法的复杂度</li>
  <li>问题1：区间调度问题</li>
</ul>

<h3 id="课程概览">课程概览</h3>

<ul>
  <li>Divide and Conquer - FFT and randomization algorithms</li>
  <li>Optimization: greedy and dynamic programming</li>
  <li>Network flow</li>
  <li>Intractability (and dealing with it)</li>
  <li>Linear programming</li>
  <li>Sublinear algorithms, approximation algorithms</li>
  <li>Advanced topics</li>
</ul>

<h3 id="相似的问题可能有不同的复杂度">相似的问题可能有不同的复杂度</h3>

<p>定义hard：如果解决问题A可以转化为解决问题B的方法来解决，那么可以认为B的复杂度是比A的复杂度高，我们就说A问题可以约化为B问题，或者说A不比B难。</p>

<ul>
  <li>P问题：在多项式时间可以得出答案的问题，即$O(n^k)$存在某个常数$k$</li>
  <li>NP问题：在多项式时间内能够被验证答案是否正确的问题</li>
  <li>NP-complete问题：和其他NP问题一样难的NP问题</li>
</ul>

<h3 id="问题1区间调度问题">问题1：区间调度问题</h3>

<p>对$n$段单独的区间资源$1, 2, \dots, n$进行请求。记$s(i), f(i)$分别为每个区间资源的开始时间和结束之间，我们约定$s(i) &lt; f(i)$。如果两段区间资源$i, j$的所处区间没有重叠,即满足$f(i) \le s(j)$或$f(j) \le s(i)$，我们就称这两段区间资源是 <strong>兼容的(compatible)</strong> 。</p>

<p>Definition of <strong>Interval Scheduling Problem</strong> :</p>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Input: $n$ requests with ${s(i), f(i)</td>
          <td>i = 1 , 2 , \dots , n}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Goal: a <strong>compatible</strong> subset of ${1,2, \dots, n}$ of maximum size</li>
  <li>Method: <strong>Select a greedy algorithm</strong></li>
</ul>

<h3 id="贪心法求解区间调度问题">贪心法求解区间调度问题</h3>

<h4 id="贪心法设计求解步骤">贪心法设计求解步骤</h4>

<ol>
  <li>按一个 <strong>规则</strong> 选取请求$i$;</li>
  <li>拒绝所有与$i$不兼容的请求；</li>
  <li>对剩下的请求，重复步骤1和2，直到所有请求都被处理。</li>
</ol>

<h4 id="如何选取合适的规则">如何选取合适的规则？</h4>

<p>可以选取的规则：</p>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />选取开始时间$s(i)$最早的请求 -&gt; 反例：当区间长度最长的请求开始时间最早</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />选取区间长度$f(i) - s(i)$最短的的请求 -&gt; 反例：两个接续进行的请求和一个与它们都不兼容的更短的请求</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />选取和其它请求不兼容数量最少的请求 -&gt; 反例：更多开始与结束时间相同的请求，会使得规则同设想情况不同</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />选取结束时间$f(i)$最早的请求</li>
</ul>

<p>通过如下两个命题证明最后一种规则是正确的规则：</p>

<ol>
  <li>
    <p>命题1（兼容性条件）：满足要求的子集，可以通过重新排列，表示为
\((s(i_1), f(i_1)), (s(i_2), f(i_2)), \dots, (s(i_k), f(i_k))\)
其中
\(s(i_1) &lt; f(i_1) \le s(i_2) &lt; f(i_2) \le \dots \le s(i_k) &lt; f(i_k)\)</p>
  </li>
  <li>
    <p>命题2：按命题1的排列，不存在与请求$i_r$和$i_{r+1}$兼容的请求$j$，使得
\(f(i_r) \le s(j), f(j) \le s(i_{r+1})\)
同时满足（对$r = 1$和$r + 1 = k$，则其中有意义的一个不等式不满足）</p>
  </li>
</ol>

<p>由上述两个命题，便可以证明“选取最早结束请求”这个规则的正确性。</p>

<h4 id="算法时间复杂度">算法时间复杂度</h4>

<p>该方法需要做一步对所有请求的结束时间排序的预处理，所需时间为$O(n\log n)$；接下来便是按序执行步骤，处理所有请求，所需时间为$O(n)$。因此算法的时间复杂度为$O(n \log n)$。</p>

<h4 id="对于贪心法的总结">对于贪心法的总结</h4>

<ul>
  <li>贪心法是一种非常 <strong>“短视”</strong> 的策略，它更看重当前情况，实现最近一步可以实现最优结果；</li>
  <li>由于贪心法的理念，如何能够通过人为设定的规则，实现当前状况得到最优解是该方法最困难的部分，而且对于很多问题，证明规则的正确性同样是一件很困难的事情；</li>
  <li>此外，由于贪心法总是考虑一步最优解的“不回头策略”，因此通过该策略解决问题不一定总能找到最优解；</li>
  <li>但是由于贪心法的高效性，这种策略应用于对于最优解要求并不严格的问题时效果比较理想，并可以作为辅助算法，结合其他策略共同解决问题。</li>
</ul>

<h3 id="加权区间调度问题和更多更改">加权区间调度问题和更多更改</h3>

<h4 id="加权区间调度问题">加权区间调度问题</h4>

<p>如果我们将问题改为 <strong>加权区间调度</strong> ，即对每段区间资源都添加一个与区间长度无关的权值$w(i)$，并将问题目标改为 <strong>求得权值相加最大的兼容请求子集</strong>。</p>

<p>此时一种可以求解的方法是 <strong>动态规划(Dynamic Programming)</strong>：</p>

<ul>
  <li>定义子问题$opt(R^{x})$为请求集$R$中开始时间大于$x$的子集的兼容请求权值相加最大值；</li>
  <li>当请求$i$纳入考虑的时候，则此时$x$应为$f(i)$，且$opt(R^x)$应当加上$w(i)$；</li>
  <li>子问题的总数为$n$，基本情况$opt(R^{f(n)}) = 0$</li>
  <li>由此可以按关系式$opt(R) = \max_{1 \le i \le n}(w(i) + opt(R^{f(i)}))$求解目标问题</li>
</ul>

<p>通过动态规划，加权区间调度问题的时间复杂度也可以达到$O(n \log n)$，<strong>但是按之前规则再次进行贪心策略的结果就会产生错误</strong>。</p>

<h4 id="进一步修改问题设定">进一步修改问题设定</h4>

<p>假设现在有$m$台处理请求的机器$\tau = {T_1, T_2,\dots, T_m}$，对于每个请求$i$，仅有子集$Q(i)\subseteq \tau$包含的机器可以处理该请求。如果每个请求的权值都是1:</p>

<ol>
  <li>问题 <strong>$m$台机器能够处理的请求最大数量</strong> 是 <strong>NP问题</strong>；</li>
  <li>问题 <strong>判断$k \le n$个请求能否被兼容执行</strong> 是 <strong>NP完全问题</strong>；</li>
  <li>问题 <strong>$m$台机器能够兼容处理的请求最大数量</strong> 是 <strong>NP难问题</strong>。</li>
</ol>

<h3 id="解决复杂问题intractability的方法">解决复杂问题(intractability)的方法</h3>

<ul>
  <li>采用近似的算法：可以提供多项式时间的优化；</li>
  <li>利用启发式算法来减少实际算例的时间；</li>
  <li>贪心或者其他实际应用有效的次优化启发式，但是无法保证效果。</li>
</ul>

<h2 id="lesson-02-divide-and-conquer">Lesson 02: Divide and Conquer</h2>

<ul>
  <li>时间复杂度的计算范式</li>
  <li>问题2：凸包问题</li>
  <li>问题3：确定中位数问题</li>
</ul>

<h3 id="分治法的算法范式">分治法的算法范式</h3>

<p>给定一个规模为$n$的问题，将其分解为$a$个规模为$\frac{n}{b}$的子问题，其中$a\ge 1, b \ge 1$。递归解决每个子问题，将子问题的结果组合在一起，得到原始问题的结果。</p>

<p>时间花费满足如下关系式：</p>

\[T(n) = aT(\frac{n}{b}) + [\mathrm{work\ for\ merge}]\]

<h3 id="问题2凸包问题">问题2：凸包问题</h3>

<h4 id="问题描述">问题描述</h4>

<p>给定平面上的$n$个点</p>

\[S = \{(x_i, y_i)|i = 1,2,\dots, n\}\]

<p>并假设不存在两个具有相同$x$坐标或者$y$坐标的点，并且不存在共线的3个点。</p>

<p><strong>凸包</strong> (Convex Hull, CH($S$)): 能够包含$S$中所有点的最小多边形。</p>

<p>易知，CH($S$)的顶点即为$S$中的点，而且我们用顺时针顺序的点列来表示CH($S$)。</p>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Input: point set $S = {(x_i, y_i)</td>
          <td>i = 1,2,\dots, n}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Goal: CH($S$) = ${p_1, p_2, \dots, p_k}$</li>
  <li>Method: <strong>Divide and Conquer</strong></li>
</ul>

<h4 id="暴力法计算凸包">暴力法计算凸包</h4>

<p>思路：通过判断$S$中任意两点的连线是否能将其余点分为两部分，来确定这两点的连线是否是凸包的一部分。</p>

<p>时间复杂度：$O(n^2)$条边，每条边进行$O(n)$次检测 -&gt; 故复杂度为$O(n^3)$</p>

<h4 id="利用分治法计算凸包">利用分治法计算凸包</h4>

<p>利用分治的思想计算凸包，首先需要进行预处理：对$S$中的所有点按$x$坐标进行排序：$O(n\log n)$</p>

<p>预处理后，按如下步骤求解CH($S$)：</p>

<ul>
  <li>将$S$按$x$坐标排序，分为左半部分$A$和右半部分$B$；</li>
  <li>计算CH($A$)和CH($B$);</li>
  <li>CH($S$) = merge(CH($A$), CH($B$)).</li>
</ul>

<h4 id="how-to-merge">How to merge?</h4>

<p>由于$A$和$B$是$S$的左半部分和右半部分，因此两个子凸包是彼此不相交的，所以通过结合子凸包CH($A$)和CH($B$)的点列，便可以得到CH($S$)。</p>

<p>假设$a_1$是CH($A$) $= (a_1, a_2,\dots, a_p)$中$x$坐标最大的点，$b_1$是CH($B$) $= (b_1, b_2,\dots, b_q)$中$x$坐标最小的点。$L$是$A$和$B$中间的一条垂直于$x$轴的直线，定义$y(i, j)$是$L$与线段$(a_i,b_j)$的交点纵坐标的值。</p>

<table>
  <tbody>
    <tr>
      <td>按如上定义，我们能够得知：CH($S$)与$L$有且只有两个交点，且上交点的值是$Y = {y(i, j)</td>
      <td>i = 1,2\dots, p;j = 1,2,\dots, q}$的最大值，下交点的值是$Y$的最小值。$L$左侧部分CH($S$)的点是CH($A$)的点，$L$右侧部分CH($S$)的点是CH($B$)的点。只要能够得知对应组成上交点的线段与下交点的线段，便可以完成Merge()操作。</td>
    </tr>
  </tbody>
</table>

<p>Algorithm(类似于double-finger的操作) for get uppertangent:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
    <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">||</span> <span class="n">y</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>   
                <span class="n">j</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>      <span class="c1">// Move right finger clockwise</span>
            <span class="k">if</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>  <span class="c1">// Move left finger anti-clockwise</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a_i</span><span class="p">,</span> <span class="n">b_j</span><span class="p">);</span>
</code></pre></div></div>

<p>对于求下交点是同理的。</p>

<h4 id="时间复杂度">时间复杂度：</h4>

<p>利用主定理，可以简单算出</p>

\[T(n) = 2T(\frac{n}{2}) + \Theta(n) = \Theta(n \log n)\]

<p>再加上预处理的的排序需要$O(n\log n)$的时间，利用分治法计算凸包的总时间复杂度为$\Theta(n\log n)$。</p>

<h3 id="问题3确定中位数问题">问题3：确定中位数问题</h3>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="Learning Notes" /><category term="“6.046”" /><summary type="html"><![CDATA[6.046: Design and Analysis of Algorithms 笔记01：]]></summary></entry><entry><title type="html">GAMES101_notes_02</title><link href="http://localhost:4000/2023/01/14/GAMES101_notes_02/" rel="alternate" type="text/html" title="GAMES101_notes_02" /><published>2023-01-14T23:44:00+08:00</published><updated>2023-01-14T23:44:00+08:00</updated><id>http://localhost:4000/2023/01/14/GAMES101_notes_02</id><content type="html" xml:base="http://localhost:4000/2023/01/14/GAMES101_notes_02/"><![CDATA[<blockquote>
  <p>GAMES101: 现代计算机图形学入门</p>

  <p>笔记02：Shading,</p>
</blockquote>

<h2 id="lesson-07-shading-1illumination-shading-and-graphics-pipeline">Lesson 07 Shading 1(Illumination, Shading and Graphics Pipeline)</h2>

<p>本讲内容：</p>

<ul>
  <li>Visibility/ occlusion
    <ul>
      <li>Z-buffering</li>
    </ul>
  </li>
  <li>Shading
    <ul>
      <li>Illumination &amp; Shading</li>
      <li>Graphics Pipeline</li>
    </ul>
  </li>
</ul>

<h3 id="visibility-可见性">Visibility 可见性</h3>

<h4 id="painters-algorithm">Painter’s Algorithm</h4>

<p>受油画绘画技术的启发，作画时应当先画远处的物体，再画近处的物体，从而保证物体遮挡的结果是正确的</p>

<p>问题是如何判断哪个物体远，哪个物体近？相同远近的物体，绘画顺序怎么样确定？</p>

<p>需要首先对三角形进行排序，需要$O(n\log n)$的时间，但是不能完全解决问题</p>

<h3 id="z-buffer-深度缓存">Z-buffer 深度缓存</h3>

<p>用于解决上述提到的问题</p>

<p>Idea:</p>

<ul>
  <li>Store current min. z-value <strong>for each sample(pixel)</strong></li>
  <li>Needs an additional buffer for depth values
    <ul>
      <li>frame buffer stores color values</li>
      <li>depth buffer (z-buffer) stores depth</li>
    </ul>
  </li>
</ul>

<p>Important: For simplicity we suppose $z$ is always positive(smaller $z$ -&gt; closer, larger $z$ -&gt; further)</p>

<h4 id="算法流程">算法流程</h4>

<ul>
  <li>Initialize depth buffer to $\infty$</li>
  <li>During rasterization:</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="p">(</span><span class="n">each</span> <span class="n">triangle</span> <span class="n">T</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="n">each</span> <span class="n">sample</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="n">in</span> <span class="n">T</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">zbuffer</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>           <span class="c1">// closest sample so far</span>
                <span class="n">framebuffer</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgb</span><span class="p">;</span>    <span class="c1">// update color</span>
                <span class="n">zbuffer</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>          <span class="c1">// update depth</span>
            <span class="k">else</span>
                <span class="p">;</span>                           <span class="c1">// do nothing, this sample is occluded</span>
</code></pre></div></div>

<p>（目前只是说明在已知深度的情况下如何处理遮挡关系，还未介绍如何确定物体深度）</p>

<h4 id="正确性和复杂度">正确性和复杂度</h4>

<p>复杂度</p>

<ul>
  <li>对于$n$个三角形只需要花费$O(n)$的时间</li>
  <li>并不是排序算法，所以时间消耗是线性的</li>
</ul>

<p>不同三角形处理顺序不改变结果(但是会被舍入误差影响)</p>

<p>Most important visibility algorithm</p>

<ul>
  <li>Implemented in hardware for all GPUs</li>
</ul>

<h4 id="对于msaa的影响">对于MSAA的影响</h4>

<p>当采用MSAA时，深度缓存应当是对每个采样点，而不是对每个像素进行采样</p>

<h2 id="shading-着色">Shading 着色</h2>

<p>目前已经学过的内容：</p>

<ul>
  <li>Position objects and the camera in the world 空间中的模型和摄像机</li>
  <li>Compute position of objects relative to the camera 计算模型位置</li>
  <li>Project objects onto the screen 投影</li>
  <li>Sample triangle coverage 光栅化</li>
</ul>

<p>下一步的操作：着色（Shading）</p>

<h3 id="definition-of-shading">Definition of Shading</h3>

<ul>
  <li>The definition in the dictionary: The darkening or coloring of an illustration or diagram with parallel lines or a block of color.</li>
  <li>The definition in this course: The process of applying a material to an object.</li>
</ul>

<h3 id="a-simple-shading-modelblinn-phong-reflectance-model">A Simple Shading Model(Blinn-Phong Reflectance Model)</h3>

<h4 id="perceptual-observations">Perceptual Observations</h4>

<ul>
  <li>Specular highlights 高光</li>
  <li>Diffuse reflection 漫反射</li>
  <li>Ambient lighting 环境光照</li>
</ul>

<h4 id="shading-is-local">Shading is Local</h4>

<p>Compute light reflected toward camera at specific <strong>shading point</strong></p>

<p>Input:</p>

<ul>
  <li>Viewer direction, $v$</li>
  <li>Surface normal, $n$</li>
  <li>Light direction(for each of many lights), $l$</li>
  <li>Surfaces parameters(colors, shininess, …)</li>
</ul>

<p>注意：着色并不是添加阴影！（shading $\ne$ shadow）</p>

<h4 id="diffuse-reflection">Diffuse Reflection</h4>

<ul>
  <li>Light is scattered uniformly in all directions
    <ul>
      <li>Surface color is the same for all viewing directions</li>
    </ul>
  </li>
  <li>But how much light(energy) is received?
    <ul>
      <li>Lambert’s cosine law：随着光线和平面法线夹角$\theta$的不断扩大，单位面积接收到的光线能量逐渐变小，比例满足$\cos \theta = l \cdot n$</li>
    </ul>
  </li>
</ul>

<h4 id="light-falloff-能量耗散">Light Falloff 能量耗散</h4>

<p>将光源视为一个持续释放能量的点，则随着传播距离的增加，能量的大小应当与距离的平方成反比。</p>

<h4 id="lambertiandiffuse-shading">Lambertian(Diffuse) Shading</h4>

<p>Shading <strong>independent</strong> of view direction</p>

\[L_d = k_d(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{l})\]

<p>其中</p>

<ul>
  <li>$L_d$: diffusely reflected light</li>
  <li>$k_d$: diffuse coefficient (color)</li>
  <li>$(I/r^2)$: energy arrived at the shading point</li>
  <li>$\max(0, \mathbf{n}\cdot \mathbf{l})$: energy received by the shading point</li>
</ul>

<h2 id="lesson-08-shading-2shading-pipeline-and-texture-mapping">Lesson 08 Shading 2(Shading, Pipeline and Texture Mapping)</h2>

<p>本讲内容：</p>

<ul>
  <li>Blinn-Phong reflectance model
    <ul>
      <li>Specular and ambient terms</li>
    </ul>
  </li>
  <li>Shading frequencies</li>
  <li>Graphics pipeline</li>
  <li>Texture mapping</li>
</ul>

<h3 id="blinn-phong-reflectance-model">Blinn-Phong reflectance model</h3>

<p>回忆上讲的漫反射项(Lambertian/Diffuse Term)，可以发现漫反射项和观测方向$v$没有关系，对任意方向的反射光强度都是相同的。</p>

<h4 id="specular-termblinn-phong">Specular Term(Blinn-Phong)</h4>

<p>Intensity <strong>depends</strong> on view direction</p>

<ul>
  <li>Bright near mirror reflection direction</li>
</ul>

<p>$v$ close to mirror direction $\Leftrightarrow$ <strong>half vector near normal</strong></p>

<ul>
  <li>Measure “near” by dot product of unit vectors</li>
</ul>

<p>引入半程向量$\mathbf{h}$，可以避免计算反射向量$r$的困难，半程向量的计算公式如下：</p>

\[\begin{align*}
    \mathbf{h}
    &amp;= bisector(\mathbf{v}, \mathbf{l})\\
    &amp;= \frac{\mathbf{v}+\mathbf{l}}{\|\mathbf{v}+\mathbf{v}\|}
\end{align*}\]

<p>则Blinn-Phong公式给出的镜面反射项为</p>

\[\begin{align*}
    L_s
    &amp;= k_s(I/r^2)\max(0, \cos \alpha)^p\\
    &amp;= k_s(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{h})^p
\end{align*}\]

<p>其中</p>

<ul>
  <li>$L_s$: Specularly reflected light</li>
  <li>$k_s$: specular coefficient</li>
  <li>余弦值添加指数参数$p$的原因：能够使高光得到加窄，使得只有最接近镜面反射的部分高光明显。一般$p$取$100-200$</li>
</ul>

<h4 id="ambient-termblinn-phong">Ambient Term(Blinn-Phong)</h4>

<p>Shading that does not depend on anything</p>

<ul>
  <li>Add constant color to account for disregarded illumination and fill in black shadows</li>
  <li>This is approximate / fake!</li>
</ul>

<p>环境光项计算公式如下：</p>

\[L_a = k_a I_a\]

<p>其中</p>

<ul>
  <li>$L_a$: Reflected ambient light</li>
  <li>$k_a$: Ambient coefficient</li>
</ul>

<p>综合上述内容，可得到Blinn-Phong反射模型：</p>

\[\begin{align*}
    L &amp;= L_a + L_d + L_s\\
    &amp;= k_aI_a + k_d(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{l}) + k_s(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{h})^p
\end{align*}\]

<h3 id="shading-frequencies-着色频率">Shading Frequencies 着色频率</h3>

<p>对每个平面上多少个点进行Shading，将会影响着色的结果</p>

<p>三种常见的着色方式：</p>

<ol>
  <li><strong>Flat</strong> Shading 逐面着色
    <ul>
      <li>Triangle face is flat - one normal vector</li>
      <li>Not good for smooth surfaces</li>
    </ul>
  </li>
  <li><strong>Gouraud</strong> shading 逐顶点着色
    <ul>
      <li>Interpolate colors from vertices across triangle</li>
      <li>Each vertex has a normal vector(how?)</li>
    </ul>
  </li>
  <li><strong>Phong</strong> shading 逐像素着色
    <ul>
      <li>Interpolate normal vectors across each triangle</li>
      <li>Compute full shading model at each pixel</li>
      <li>Not the Blinn-Phong Reflectance Model</li>
    </ul>
  </li>
</ol>

<p>当几何体足够复杂的时候，逐面着色和逐顶点着色与逐像素着色的区别会变小。</p>

<h4 id="define-per-vertex-normal-vectors">Define Per-Vertex Normal Vectors</h4>

<p>Best to get vertex normals from the underlying geometry. Otherwise have to infer vertex normal from triangle faces</p>

<ul>
  <li>Simple scheme: <strong>Average surrounding face normals</strong></li>
</ul>

\[N_v = \frac{\sum_i N_i}{\|\sum_iN_i\|}\]

<h4 id="define-per-pixel-normal-vectors">Define Per-Pixel Normal Vectors</h4>

<p>Barycentric interpolation (introducing soon) of vertex normals.</p>

<p>Don’t forget to normalize the interpolated directions</p>

<h3 id="graphicsreal-time-rendering-pipeline">Graphics(Real-time Rendering) Pipeline</h3>

<p>管线：从Input到Output的过程：</p>

<ul>
  <li>Input: Vertices in 3D space</li>
  <li>Application:
    <ol>
      <li>Vertex Processing: Vertices positioned in screen space</li>
      <li>Triangle Processing: Triangles positioned in screen space</li>
      <li>Rasterization: Fragments(one per covered sample)</li>
      <li>Fragment Processing: Shaded fragments</li>
      <li>Framebuffer Operations: Display</li>
    </ol>
  </li>
  <li>Output: images(pixels)</li>
</ul>

<p>过去学习的内容对应到pipeline中：</p>

<ul>
  <li>MVP transforms: 1</li>
  <li>Sampling triangle coverage: 3</li>
  <li>Z-Buffer Visibility Tests: 4</li>
  <li>Shading: 1, 4(考虑不同的着色频率，着色发生的环节会不同)</li>
  <li>Texture mapping(introducing soon): 1, 4</li>
</ul>

<h4 id="shader-programs">Shader Programs</h4>

<ul>
  <li>Program vertex and fragment processing stages(分别称为vertex-shader和fragment-shader/pixel-shader)</li>
  <li>Describe operation on a single vertex(or fragment)</li>
</ul>

<p>Example GLSL fragment shader program</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">my</span> <span class="n">Texture</span><span class="p">;</span> <span class="c1">// program parameter</span>
<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightDir</span><span class="p">;</span>        <span class="c1">// program parameter</span>
<span class="n">varying</span> <span class="n">vec2</span> <span class="n">uv</span><span class="p">;</span>              <span class="c1">// per fragment value(interp. by rasterizer)</span>
<span class="n">varying</span> <span class="n">vec3</span> <span class="n">norm</span><span class="p">;</span>            <span class="c1">// per fragment value(interp. by rasterizer)</span>

<span class="kt">void</span><span class="p">(</span><span class="n">diffuseShader</span><span class="p">)()</span>
<span class="p">{</span>
  <span class="n">vec3</span> <span class="n">kd</span><span class="p">;</span>
  <span class="n">kd</span> <span class="o">=</span> <span class="n">texture2d</span><span class="p">(</span><span class="n">myTexture</span><span class="p">,</span> <span class="n">uv</span><span class="p">);</span>                <span class="c1">// material color from texture</span>
  <span class="n">kd</span> <span class="o">*=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">norm</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  <span class="c1">// Lambertian shading model</span>
  <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">kd</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>                 <span class="c1">// Output fragment color</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Remark:</p>

<ul>
  <li>Shader function executes once per fragment;</li>
  <li>Outputs color of surface at the current fragment’s screen sample position;</li>
  <li>This shader performs a texture lookup to obtain the surfaces’s material color at this point, then performs a diffuse lighting calculation.</li>
</ul>

<p><a href="https://shadertoy.com/view/ld3Gz2">Snail Shader Program</a></p>

<h4 id="modern-development-in-cg">Modern development in CG</h4>

<p>（省略该部分内容）</p>

<h3 id="texture-mapping">Texture Mapping</h3>

<p>本质：在物体不同位置定义不同属性</p>

<h4 id="surfaces-are-2d">Surfaces are 2D</h4>

<p>Surface lives in 3D world space. Every 3D surface point also has a place where it goes in the 2D image(texture).</p>

<p>需要考虑物体平面和纹理空间的映射关系，纹理空间坐标系通过$u-v$坐标系表示，通过映射关系可以实现从$[0,1]^2$纹理空间到物体表面的映射</p>

<h4 id="textures-can-be-used-multiple-times">Textures can be used multiple times</h4>

<p>通过设计纹理图样，可以实现同样纹理贴图的无缝衔接</p>

<h4 id="interpolation-across-triangles-barycentric-coordinatesnext-lesson">Interpolation Across Triangles: Barycentric Coordinates(next lesson)</h4>

<h2 id="lesson-09-shading-3texture-mapping-cont">Lesson 09 Shading 3(Texture Mapping Cont.)</h2>

<p>本讲内容：</p>

<ul>
  <li></li>
</ul>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="Learning Notes" /><category term="GAMES101" /><summary type="html"><![CDATA[GAMES101: 现代计算机图形学入门 笔记02：Shading,]]></summary></entry><entry><title type="html">GAMES101_notes_01</title><link href="http://localhost:4000/2023/01/02/GAMES101_notes_01/" rel="alternate" type="text/html" title="GAMES101_notes_01" /><published>2023-01-02T15:59:00+08:00</published><updated>2023-01-02T15:59:00+08:00</updated><id>http://localhost:4000/2023/01/02/GAMES101_notes_01</id><content type="html" xml:base="http://localhost:4000/2023/01/02/GAMES101_notes_01/"><![CDATA[<blockquote>
  <p>GAMES101: 现代计算机图形学入门</p>

  <p>笔记01：Introduction, Transformation, Rasterization</p>
</blockquote>

<h2 id="lesson-02-review-of-linear-algebra-向量与线性代数">Lesson 02 Review of Linear Algebra 向量与线性代数</h2>

<h3 id="图形学依赖">图形学依赖</h3>

<ol>
  <li>基础数学：线性代数 微积分 统计学；</li>
  <li>基础物理学：光学 力学；</li>
  <li>其他： 信号处理 数值分析</li>
</ol>

<h3 id="线性代数">线性代数</h3>

<p>向量 矩阵 。。。</p>

<h2 id="lesson-03-transformation-变换">Lesson 03 Transformation 变换</h2>

<h3 id="为什么研究变换">为什么研究变换</h3>

<ul>
  <li>Modeling 模型变换</li>
  <li>Viewing 视角变换（从三维到二维的）投影</li>
</ul>

<p>广泛应用</p>

<h3 id="二维变换旋转-放缩-裁剪">二维变换：旋转 放缩 裁剪</h3>

<ul>
  <li>
    <p>缩放变换(Scale)：</p>

\[\begin{bmatrix}x'\\ y'\end{bmatrix}
  =
  \begin{bmatrix}s_x &amp; 0 \\ 0 &amp; s_y\end{bmatrix}
  \begin{bmatrix}x\\ y\end{bmatrix}\]
  </li>
  <li>
    <p>反射变换(Reflection):</p>

\[\begin{bmatrix}x'\\ y'\end{bmatrix}
  =
  \begin{bmatrix}-1 &amp; 0 \\ 0 &amp; 1\end{bmatrix}
  \begin{bmatrix}x\\ y\end{bmatrix}\]
  </li>
  <li>
    <p>切变(Shear)</p>

\[\begin{bmatrix}x'\\ y'\end{bmatrix}
  =
  \begin{bmatrix}1 &amp; a \\ 0 &amp; 1\end{bmatrix}
  \begin{bmatrix}x\\ y\end{bmatrix}\]
  </li>
  <li>
    <p>旋转变换(Rotate)：默认关于原点逆时针旋转。</p>

\[\begin{bmatrix}x'\\ y'\end{bmatrix}
  =
  \begin{bmatrix}\cos \theta &amp; -\sin \theta \\ \sin \theta &amp; \cos \theta\end{bmatrix}
  \begin{bmatrix}x\\ y\end{bmatrix}\]
  </li>
</ul>

<p>以上变换的共同点：线性变换（可以通过矩阵来表示）：</p>

\[\begin{bmatrix}x'\\ y'\end{bmatrix}
    =
    \begin{bmatrix}a &amp; b \\ c &amp; d\end{bmatrix}
    \begin{bmatrix}x\\ y\end{bmatrix}\]

<h3 id="齐次坐标">齐次坐标</h3>

<p>平移变换(Transition)：无法通过上述形式的线性变换矩阵来表示。</p>

\[\begin{bmatrix}x'\\ y'\end{bmatrix}
    =
    \begin{bmatrix}a &amp; b \\ c &amp; d\end{bmatrix}
    \begin{bmatrix}x\\ y\end{bmatrix}
     +
     \begin{bmatrix}t_x\\ t_y\end{bmatrix}\]

<p>由此引入了 <strong>齐次坐标(Homogenous Coordinates)</strong> 这个概念：
对于二维向量和二维点，增加第三个分量($w$-coordinate)</p>

<ul>
  <li>二维点： $(x, y, 1)^\mathrm{T}$</li>
  <li>二维向量： $(x, y, 0)^\mathrm{T}$</li>
</ul>

<p>由此平移操作可以用一个矩阵乘法的形式表示：</p>

\[\begin{bmatrix}x'\\ y' \\ w'\end{bmatrix}
    =
    \begin{bmatrix}1 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; t_y \\ 0 &amp; 0 &amp; 1\end{bmatrix}
    \begin{bmatrix}x\\ y \\ w\end{bmatrix}\]

<p>向量的$w$分量为$0$的原因：因为向量具有 <strong>平移不变性</strong></p>

<ul>
  <li>vector + vector = vector</li>
  <li>point - point = vector</li>
  <li>point + vector = point</li>
  <li>point + point = ？？</li>
</ul>

<p>$
    \begin{pmatrix}x\ y \ w\end{pmatrix}
$
对应二维点
$
    \begin{pmatrix}x/w\ y/w \ 1\end{pmatrix}, w \ne 0
$</p>

<p>由此两个齐次坐标点的相加可以视为两点的 <strong>加权平均</strong></p>

<h3 id="仿射变换">仿射变换</h3>

\[\begin{pmatrix}x'\\ y' \\ 1\end{pmatrix}
    =
    \begin{pmatrix}a &amp; b &amp; t_x \\ c &amp; d &amp; t_y \\ 0 &amp; 0 &amp; 1\end{pmatrix}
    \begin{pmatrix}x\\ y \\ 1\end{pmatrix}\]

<p>Scale:</p>

\[S(s_x, s_y)
    =
    \begin{pmatrix}s_x &amp; 0 &amp; 0 \\ 0 &amp; s_y &amp; 0 \\ 0 &amp; 0 &amp; 1\end{pmatrix}\]

<p>Rotation:</p>

\[R(\alpha)
    =
    \begin{pmatrix}\cos \alpha &amp; -\sin \alpha &amp; 0 \\ \sin \alpha &amp; \cos \alpha &amp; 0 \\ 0 &amp; 0 &amp; 1\end{pmatrix}\]

<p>Translation:</p>

\[T(t_x, t_y)
    =
    \begin{pmatrix}1 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; t_y \\ 0 &amp; 0 &amp; 1\end{pmatrix}\]

<h3 id="逆变换变换组合变换分解">逆变换、变换组合、变换分解</h3>

\[A_n(\dots A_2(A_1 (x))) = \mathbf{A}_n \cdots \mathbf{A}_2\cdot \mathbf{A}_1 \cdot
\begin{pmatrix}x \\ y \\ 1\end{pmatrix}\]

<p>复杂变换的分解：</p>

<ul>
  <li>如何关于固定点$c$旋转？</li>
</ul>

<ol>
  <li>将图形平移$-c$；</li>
  <li>旋转</li>
  <li>平移$c$</li>
</ol>

\[\mathbf{M} = \mathbf{T}(c)\cdot \mathbf{R}(\alpha) \cdot \mathbf{T}(-c)\]

<h3 id="三维变换">三维变换</h3>

<p>仍然利用齐次坐标系统：</p>

<ul>
  <li>三维点坐标： $(x, y, z, 1)^\mathrm{T}$</li>
  <li>三维向量坐标： $(x, y, z, 0)^\mathrm{T}$</li>
</ul>

<p>定义$(x, y, z, w)^\mathrm{T}(w\ne 0)$表示三维空间中点
\((x/w, y/w, z/w)^\mathrm{T}\)</p>

<p>三维空间中仿射变换矩阵：
\(\begin{pmatrix}x'\\ y' \\ z'\\ 1\end{pmatrix}
    =
    \begin{pmatrix}a &amp; b &amp; c &amp; t_x \\ d &amp; e &amp; f &amp; t_y \\ g &amp; h &amp; i &amp; t_z \\ 0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}
    \begin{pmatrix}x\\ y \\ z\\ 1\end{pmatrix}\)
上述形式的仿射变换矩阵可以视作 <strong>先进行线性变换再进行平移变换</strong></p>

<h2 id="lesson-04-transformation-cont">Lesson 04 Transformation Cont</h2>

<h3 id="对上节课的补充旋转变换的逆变换矩阵形式">对上节课的补充：旋转变换的逆变换矩阵形式</h3>

\[R(\alpha)
    =
    \begin{pmatrix}\cos \alpha &amp; -\sin \alpha &amp; 0 \\ \sin \alpha &amp; \cos \alpha &amp; 0 \\ 0 &amp; 0 &amp; 1\end{pmatrix}\]

\[R(-\alpha)
    =
    \begin{pmatrix}\cos \alpha &amp; \sin \alpha &amp; 0 \\ -\sin \alpha &amp; \cos \alpha &amp; 0 \\ 0 &amp; 0 &amp; 1\end{pmatrix}
    =
    R(\alpha)^{-1}
    =
    R(\alpha)^\mathrm{T}\]

<h3 id="三维坐标系下的变换">三维坐标系下的变换</h3>

<ul>
  <li>三维点坐标： $(x, y, z, 1)^\mathrm{T}$</li>
  <li>三维向量坐标： $(x, y, z, 0)^\mathrm{T}$</li>
</ul>

<p>Scale
\(\mathbf{S}(s_x, s_y, s_z)=
    \begin{pmatrix}s_x &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; s_y &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; s_z &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\)</p>

<p>Translation
\(\mathbf{T}(t_x, t_y, t_z)=
    \begin{pmatrix}1 &amp; 0 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; 0 &amp; t_y \\ 0 &amp; 0 &amp; 1 &amp; t_z \\ 0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\)</p>

<p>Rotation</p>

\[\mathbf{R}_x(\alpha)=
    \begin{pmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \cos\alpha &amp; -\sin\alpha &amp; 0 \\ 0 &amp; \sin\alpha &amp; \cos\alpha &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]

\[\mathbf{R}_y(\alpha)=
    \begin{pmatrix}\cos\alpha &amp; 0 &amp; \sin\alpha &amp; 0 \\
     0 &amp; 1 &amp; 0 &amp; 0 \\
      -\sin\alpha &amp; 0 &amp; \cos\alpha &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]

\[\mathbf{R}_z(\alpha)=
    \begin{pmatrix}\cos\alpha &amp; -\sin\alpha &amp; 0 &amp; 0 \\ \sin\alpha &amp; \cos\alpha &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]

<p>如何考虑复杂的三维旋转变换？</p>

\[\mathbf{R}_{xyz}(\alpha, \beta, \gamma) = \mathbf{R}_x(\alpha)\mathbf{R}_y(\beta)\mathbf{R}_z(\gamma)\]

<p>$\alpha, \beta, \gamma$被称为欧拉角</p>

<h3 id="rodrigues-rotation-formula">Rodrigues’ Rotation Formula</h3>

<p>Rotation by angle $\alpha$ around axis $\mathbf{n}$</p>

\[\mathbf{R}(\mathbf{n}, \alpha) = \cos(\alpha) \mathbf{I} + (1-\cos(\alpha))\mathbf{n}\mathbf{n}^\mathrm{T} + \sin \alpha     \begin{pmatrix}0 &amp; -n_z &amp; n_y \\ n_z &amp; 0 &amp; -n_x \\  -n_y &amp; n_x &amp; 0\end{pmatrix}\]

<h3 id="viewing-transformation">Viewing transformation</h3>

<ul>
  <li>View/Camera transformation 观测变换/视图变换</li>
  <li>Projection transformation 投影变换
    <ul>
      <li>Orthographic projection 正交</li>
      <li>Perspective projection 透视</li>
    </ul>
  </li>
</ul>

<p>如何拍一张照片？MVP Transformations</p>

<ul>
  <li>model transformation 模型变换</li>
  <li><strong>view transformation 视图变换</strong></li>
  <li>projection transformation 投影变换</li>
</ul>

<p>如何确定相机位置？</p>

<ul>
  <li>Position $\vec{e}$</li>
  <li>Look-at/ gaze direction $\hat{g}$</li>
  <li>Up direction $\hat{t}$</li>
</ul>

<h4 id="约定相机始终位于__原点__永远向-z方向看永远以y轴为固定向上方向改变其他物体的位置而不改变相机的标准位置">约定：相机始终位于__原点__，永远向$-z$方向看，永远以$y$轴为固定向上方向，改变其他物体的位置而不改变相机的标准位置</h4>

<p>在数学上通过矩阵变换将相机移到标准位置：</p>

<ul>
  <li>将位置 $\vec{e}$ 移到原点;</li>
  <li>旋转 $\hat{g}$ 到 $-z$ 方向；</li>
  <li>旋转 $\hat{t}$ 到 $y$ 方向。</li>
</ul>

<p>进行矩阵变换则为：</p>

\[\mathbf{M}_{view} = \mathbf{R}_{view}\mathbf{T}_{view}\]

<p>其中</p>

<ul>
  <li>
\[\mathbf{T}_{view}=
  \begin{pmatrix}
  1 &amp; 0 &amp; 0 &amp; -x_e \\
  0 &amp; 1 &amp; 0 &amp; -y_e \\
  0 &amp; 0 &amp; 1 &amp; -z_e \\
  0 &amp; 0 &amp; 0 &amp; 1
  \end{pmatrix}\]
  </li>
  <li>由于对于 $\mathbf{R}_{view}$ 的逆矩阵，是将 $x$ 轴旋转到 $\hat{g}\times \hat{t}$，将 $y$ 轴旋转到 $\hat{t}$ ，将 $z$ 轴旋转到 $-\hat{g}$ 上，故
\(\mathbf{R}_{view}^{-1}=
  \begin{pmatrix}
  x_{\hat{g}\times\hat{t}} &amp; x_{\hat{t}} &amp; x_{-\hat{g}} &amp; 0
  \\ y_{\hat{g}\times\hat{t}} &amp; y_{\hat{t}} &amp; y_{-\hat{g}} &amp; 0
  \\ z_{\hat{g}\times\hat{t}} &amp; z_{\hat{t}} &amp; z_{-\hat{g}} &amp; 0
  \\ 0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\)</li>
  <li>因此
\(\mathbf{R}_{view}= (\mathbf{R}_{view}^{-1})^\mathrm{T} =
  \begin{pmatrix}
  x_{\hat{g}\times\hat{t}} &amp; y_{\hat{g}\times\hat{t}} &amp; z_{\hat{g}\times\hat{t}} &amp; 0
  \\ x_{\hat{t}} &amp; y_{\hat{t}} &amp; z_{\hat{t}} &amp; 0
  \\ x_{-\hat{g}} &amp; y_{-\hat{g}} &amp; z_{-\hat{g}} &amp; 0
  \\ 0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\)</li>
</ul>

<h3 id="projection-transformation">Projection Transformation</h3>

<ul>
  <li>正交投影</li>
  <li>透视投影</li>
</ul>

<h4 id="正交投影">正交投影</h4>

<p>简单理解正交投影：</p>

<ul>
  <li>将照相机固定在原点，看向 $-z$ 方向，上方为 $y$ 方向；</li>
  <li>抛掉所有 $z$ 方向坐标；</li>
  <li>平移和放缩结果的矩形画面到 $[-1, 1]^2$上。</li>
</ul>

<p>约定俗成的方法：</p>

<ul>
  <li>将包裹全部物体的长方体 $[l, r]\times[b, t]\times[f, n]$ 映射到标准立方体(canonical cube) $[-1, 1]^3$ ，先做平移，将中心移到原点之后再进行放缩。</li>
  <li>变换矩阵为：
\(\mathbf{M}_{ortho}  =
\begin{pmatrix}
\frac{2}{r - l} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{2}{t - b} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \frac{2}{n - f} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; -\frac{r + l}{2} \\
0 &amp; 1 &amp; 0 &amp; -\frac{t + b}{2} \\
0 &amp; 0 &amp; 1 &amp; -\frac{n + f}{2} \\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\)</li>
</ul>

<h4 id="透视投影">透视投影</h4>

<p>回顾数学基础：</p>

<ul>
  <li>对于齐次坐标系， $(x, y, z, 1)$ 和 $(kx, ky, kz, k), k \ne 0$ 都表示三维空间中 $(x, y, z)$ 这个点</li>
</ul>

<p>如何做透视投影：</p>

<ul>
  <li>首先，将棱台的远平面压缩成和近平面相同大小的长方形 ($\mathbf{M_{persp\rightarrow ortho}}$)</li>
  <li>将压缩后的远平面通过正交投影 ($\mathbf{M}_{ortho}$)</li>
</ul>

<h4 id="如何求mathbfm_persprightarrow-ortho">如何求$\mathbf{M}_{persp\rightarrow ortho}$？</h4>

<p>根据相似三角形的理论，如果近平面到原点的距离是 $n$，那么点 $(x, y, z)$ 通过相似变换映射到近平面上的点 $(x’, y’, z’)$ 应当满足
\(y' = \frac{n}{z}y,\quad x' = \frac{n}{z} x.\)
由于这样的相似变换总是会非线性的改变在棱台内点的 $z$ 分量，因此我们希望能够在这些变换中找到满足如下两点性质的一类变换：</p>

<ul>
  <li>对位于近平面，即 $z = n$ 的所有点，在相似变换后仍然保持 $z’ = n$；</li>
  <li>对位于远平面，即 $z = f$ 的所有店，在相似变换后仍然保持 $z’ = f$.</li>
</ul>

<p>由此我们可以通过逐行凑矩阵的方式，推得透视投影变换矩阵 $\mathbf{M}_{persp\rightarrow ortho}$ 应当为</p>

\[\mathbf{M}_{persp\rightarrow ortho}
 =
\begin{pmatrix}
n &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; n &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; n+f &amp; -nf\\
0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}\]

<p>可以验证</p>

\[\mathbf{M}_{persp\rightarrow ortho}
\begin{pmatrix}
x \\ y \\ n \\ 1
\end{pmatrix}
 =

\begin{pmatrix}
nx \\ ny \\ n^2 \\ n
\end{pmatrix}
\Leftrightarrow
\begin{pmatrix}
x \\ y \\ n \\ 1
\end{pmatrix}\]

\[\mathbf{M}_{persp\rightarrow ortho}
\begin{pmatrix}
x \\ y \\ f \\ 1
\end{pmatrix}
 =
\begin{pmatrix}
nx \\ ny \\ f^2 \\ f
\end{pmatrix}
\Leftrightarrow
\begin{pmatrix}
\frac{nx}{f} \\ \frac{ny}{f} \\ f \\ 1
\end{pmatrix}\]

<p>满足我们最开始的要求。</p>

<p>最后，我们结合正交投影部分的结论，可以推出</p>

\[\mathbf{M}_{persp}
 =

\mathbf{M}_{othro}
\mathbf{M}_{persp\rightarrow ortho}\]

<h2 id="lesson-05-rasterization-光栅化-1triangles">Lesson 05 Rasterization 光栅化 1(Triangles)</h2>

<ul>
  <li>Viewport transformation</li>
  <li>Rasterization
    <ul>
      <li>Different raster displays</li>
      <li>Rasterizing a triangle</li>
    </ul>
  </li>
</ul>

<h3 id="viewport-transformation">Viewport transformation</h3>

<p>关于视锥的更多定义：</p>

<ul>
  <li>近平面的宽高比 aspect ratio = width/height</li>
  <li>垂直可视角度 vertical field-of-view(fovY) 近平面上下边中点和原点张成的角度
\(\tan \frac{fovY}{2} =\frac{t}{|n|}\\
aspect = \frac{r}{t}\)</li>
</ul>

<p>What’s after MVP? -&gt; $[-1, 1]^3$的立方体</p>

<h3 id="from-canonical-cube-to-screen-rasterization光栅化">From Canonical Cube to Screen: Rasterization(光栅化)</h3>

<p>What is a screen?</p>

<ul>
  <li>An array of pixels</li>
  <li>Size of the array: resolution</li>
  <li>A typical kind of raster display</li>
</ul>

<p>Raster = screen in German</p>

<ul>
  <li>Rasterize = drawing onto the screen</li>
</ul>

<p>Pixel (FYI, short for “picture element”)</p>

<ul>
  <li>For now: A pixel is a little square with uniform color</li>
  <li>Color is a mixture of (red, green, blue)</li>
</ul>

<p>定义屏幕空间：
左下角为原点，向右为$x$轴正方向，向上为$y$轴正方向，并做如下约定：</p>

<ul>
  <li>像素坐标由 $(x, y)$ 的形式组成，其中 $x, y$ 均为整数；</li>
  <li>像素坐标取值从 $(0, 0)$ 到 $(width - 1, height - 1)$;</li>
  <li>每颗像素 $(x, y)$ 的中心位于 $(x + 0.5, y + 0.5)$；</li>
  <li>屏幕覆盖范围是 $[0, width]\times [0, height]$</li>
</ul>

<p>接下来如何处理？</p>

<ul>
  <li>对于 $z$ 方向的值：先不管；</li>
  <li>对于 $x-y$ 平面：将平面 $[-1, 1]^2$ 映射到 $[0, width]\times [0, height]$</li>
</ul>

<p>视口变换</p>

\[\mathbf{M}_{viewport}
 =

\begin{pmatrix}
\frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2} \\
0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2} \\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\]

<p>接下来：通过光栅化，将三角形转化成像素</p>

<h4 id="三角形基本图形元素">三角形：基本图形元素</h4>

<p>Why triangles?</p>

<ul>
  <li>Most basic polygon
    <ul>
      <li>Can break up other polygons</li>
    </ul>
  </li>
  <li>Unique properties
    <ul>
      <li>Guaranteed to be planar</li>
      <li>Well-defined interior</li>
      <li>Well-defined method for interpolating values at vertices over triangle (barycentric interpoation)</li>
    </ul>
  </li>
</ul>

<p>What Pixel Values Arrpoximate a Triangle?</p>

<ul>
  <li>Input: position of triangle vertices projected on screen</li>
  <li>Output: set of pixel values approximating triangle</li>
</ul>

<p>A simple approach: Sampling(采样)</p>

<p>Sampling is a core idea in graphics.</p>

<ul>
  <li>We sample time(1D), area(2D), directin(2D), volume(3D)…</li>
</ul>

<h4 id="sample-if-each-pixel-center-is-inside-triangle">Sample If Each Pixel Center is Inside Triangle</h4>

\[inside(t, x, y) =
\left\{
\begin{array}{lr}
1 &amp; \mathrm{Point(x, y)\ is\ in\ triangle\ t}\\
0 &amp; \mathrm{else}
\end{array}
\right.\]

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">xmax</span><span class="p">;</span> <span class="o">++</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">ymax</span><span class="p">;</span> <span class="o">++</span><span class="n">y</span><span class="p">)</span>
        <span class="n">image</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">inside</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">);</span>
</code></pre></div></div>

<p>应当如何实现 $inside(tri, x, y)$ ? -&gt; 利用向量叉积。</p>

<ul>
  <li>将三角形三个顶点记为A、B、C，待测试点记为P；</li>
  <li>分别测试AB和BP、BC和CP、CA和AP的叉积；</li>
  <li>如果三个结果符号相同，则认为P在三角形ABC内；否则认为P在三角形ABC外。</li>
</ul>

<h4 id="进一步的优化">进一步的优化</h4>

<ul>
  <li>(Axis-Aligned )Bounding Box(包围盒，AABB)，可以减少检测像素的数量。</li>
  <li>Incremental Triangle Traversal：可以优化应用AABB效果不好的情况。</li>
</ul>

<h4 id="光栅化中的一个问题aliasing走样jaggies锯齿">光栅化中的一个问题：Aliasing(走样)–Jaggies(锯齿)</h4>

<h2 id="lesson-06-rasterization-2-antialiasing-and-z-buffering">Lesson 06 Rasterization 2 (Antialiasing and Z-buffering)</h2>

<h3 id="采样理论">采样理论</h3>

<ul>
  <li>Sampling is Ubiquitous in Computer Graphics
    <ul>
      <li>Rasterization = Sample 2D Positions</li>
      <li>Photograph = Sample Image Sensor Plane</li>
      <li>Video = Sample Time</li>
    </ul>
  </li>
  <li>Sampling Artifacts: (Errors/Mistakes/Inaccuracies) in Computer Graphics
    <ul>
      <li>Jaggies(Staircase Pattern)</li>
      <li>Moire Patterns in Imaging</li>
      <li>Wagon wheel effect(False Motion)</li>
    </ul>
  </li>
  <li>Behind the Aliasing Artifacts: Signals are changing too fast(high frequency) but sampled too slowly.</li>
</ul>

<h3 id="antialiasing-idea-blurringpre-filtering-before-sampling">Antialiasing Idea: Blurring(Pre-Filtering) Before Sampling</h3>

<p>举例：对三角形光栅化的时候，在采样之前对边缘进行模糊，之后再进行采样，可以使得边缘更加平滑。</p>

<p>Blurred aliasing: Sample then filter -&gt; WRONG!</p>

<p>Filter then sample -&gt; RIGHT!</p>

<h3 id="frequency-domain">Frequency Domain</h3>

<p>Fourier Transform</p>

\[F(\omega) = \int_{-\infty}^{\infty} f(x) e^{-2\pi i \omega x}dx\]

<p>Inverse Fourier Transform</p>

\[f(x) = \int_{-\infty}^{\infty}F(\omega)e^{2\pi i \omega x}d\omega\]

<p>Undersampling Creates Frequency Aliases. High-frequency signal is insufficiently sampled: samples erroneously appear to be from a low-frequency signal.</p>

<p>Two frequencies that are indistinguishable at a given sampling rate are called “aliass”.</p>

<h3 id="filtering--getting-rid-of-certain-frequency-contents">Filtering = Getting rid of certain frequency contents</h3>

<h3 id="filtering--convolution--averaging">Filtering = Convolution (= Averaging)</h3>

<p>Convolution Theorem</p>

<p>Convolution in the spatial domain is equal to multiplication in the frequency domain, and vice versa</p>

<h3 id="sampling--repeating-frequency-contents">Sampling = Repeating Frequency Contents</h3>

<h3 id="aliasing--mixed-frequency-contents">Aliasing = Mixed Frequency Contents</h3>

<h3 id="how-can-we-reduce-aliasing-error">How Can We Reduce Aliasing Error?</h3>

<ul>
  <li>Option 1: Increase samplint rate
    <ul>
      <li>Essentially increasing the distance between replicas in the Fourier domain</li>
      <li>Higher resolution displays, sensors, framebuffers…</li>
      <li>But: costly &amp; may need very high resolution</li>
    </ul>
  </li>
  <li>Option 2: Antialiasing
    <ul>
      <li>Making Fourier contents “narrower” before repeating</li>
      <li>i.e. Filtering out high frequencies before sampling</li>
    </ul>
  </li>
</ul>

<h3 id="antialiasing-by-averaging-values-in-pixel-area">Antialiasing By Averaging Values in Pixel Area</h3>

<p>Solution:</p>

<ul>
  <li><strong>Convolve</strong> f(x,y) by a 1-pixel box-blur
    <ul>
      <li>Recall: convolving = filtering = averaging</li>
    </ul>
  </li>
  <li><strong>Then Sample</strong> at every pixel’s center</li>
</ul>

<h3 id="antialiasing-by-supersamplingmsaa-multisampling-antialiasing">Antialiasing By Supersampling(MSAA, multisampling antialiasing)</h3>

<p><strong>Supersampling</strong>: Approximate the effect of the 1-pixel box filter by sampling multiple locations within a pixel and averaing their values</p>

<p>MSAA解决的是对信号的模糊的操作，而采样的操作其实与MSAA没有关系（并不是直接提高屏幕的分辨率）</p>

<h3 id="antialiasing-today">Antialiasing Today</h3>

<ul>
  <li>No free lunch!
    <ul>
      <li>What’s the cost of MSAA？</li>
    </ul>
  </li>
  <li>Milestones
    <ul>
      <li>FXAA(Fast Approximate AA) 一种后处理解决方案</li>
      <li>TAA(Temporal AA) 考虑随时间变化时前后帧的叠加结果</li>
    </ul>
  </li>
  <li>Super resolution/ Super sampling 采样率不足的问题
    <ul>
      <li>From low resolution to high resolution</li>
      <li>Essentially still “not enough samples” problem</li>
      <li>DLSS(Deep Learning Super Sampling)</li>
    </ul>
  </li>
</ul>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="Learning Notes" /><category term="GAMES101" /><summary type="html"><![CDATA[GAMES101: 现代计算机图形学入门 笔记01：Introduction, Transformation, Rasterization]]></summary></entry><entry><title type="html">Week_011 Record</title><link href="http://localhost:4000/2022/11/21/Week_011_Record/" rel="alternate" type="text/html" title="Week_011 Record" /><published>2022-11-21T21:15:00+08:00</published><updated>2022-11-21T21:15:00+08:00</updated><id>http://localhost:4000/2022/11/21/Week_011_Record</id><content type="html" xml:base="http://localhost:4000/2022/11/21/Week_011_Record/"><![CDATA[<p>My week’s record during postgraduate period.</p>

<ul>
  <li>
    <p>Monday</p>
  </li>
  <li>
    <p>Tuesday</p>
  </li>
</ul>

<p>leetcode top100: 8/100</p>

<ul>
  <li>Wednesday</li>
</ul>

<p>leetcode top100: 11/100</p>

<ul>
  <li>Thursday</li>
</ul>

<p>leetcode top100: 13/100</p>

<ul>
  <li>
    <p>Friday</p>
  </li>
  <li>
    <p>Saturday</p>
  </li>
  <li>
    <p>Sunday</p>
  </li>
  <li>
    <p>Summary</p>
  </li>
</ul>

<p><a href="https://zhengtongdu.github.io/2022/11/14/Week_010_Record/">See last week’s record</a></p>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="research_record" /><summary type="html"><![CDATA[My week’s record during postgraduate period.]]></summary></entry><entry><title type="html">Week_010 Record</title><link href="http://localhost:4000/2022/11/14/Week_010_Record/" rel="alternate" type="text/html" title="Week_010 Record" /><published>2022-11-14T00:38:00+08:00</published><updated>2022-11-14T00:38:00+08:00</updated><id>http://localhost:4000/2022/11/14/Week_010_Record</id><content type="html" xml:base="http://localhost:4000/2022/11/14/Week_010_Record/"><![CDATA[<p>My  week’s record during postgraduate period.</p>

<ul>
  <li>Monday</li>
</ul>

<p>Running 5.02 km in 33m25s</p>

<p>6.046 Recitation 01</p>

<p>6.046 Recitation 02</p>

<ul>
  <li>
    <p>Tuesday</p>
  </li>
  <li>
    <p>Wednesday</p>
  </li>
</ul>

<p>6.046 Problem Set 01</p>

<p>6.046 Problem Set 02</p>

<p>Choosing what emacs configuration.</p>

<ul>
  <li>Thursday</li>
</ul>

<p>leetcode top100: 4/100</p>

<ul>
  <li>Friday</li>
</ul>

<p>leetcode top100: 6/100</p>

<ul>
  <li>Saturday</li>
</ul>

<p>Relaxing</p>

<p>Running 5.06 km in 31m15s</p>

<ul>
  <li>Sunday</li>
</ul>

<p>Writing design document</p>

<p>Running 5.03 km in 30m13s</p>

<ul>
  <li>Summary</li>
</ul>

<p><a href="https://zhengtongdu.github.io/2022/11/07/Week_009_Record/">See last week’s record</a></p>

<p><a href="https://zhengtongdu.github.io/2022/11/21/Week_011_Record/">See next week’s record</a></p>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="research_record" /><summary type="html"><![CDATA[My week’s record during postgraduate period.]]></summary></entry><entry><title type="html">Week_009 Record</title><link href="http://localhost:4000/2022/11/07/Week_009_Record/" rel="alternate" type="text/html" title="Week_009 Record" /><published>2022-11-07T19:30:00+08:00</published><updated>2022-11-07T19:30:00+08:00</updated><id>http://localhost:4000/2022/11/07/Week_009_Record</id><content type="html" xml:base="http://localhost:4000/2022/11/07/Week_009_Record/"><![CDATA[<p>My  week’s record during postgraduate period.</p>

<ul>
  <li>Monday</li>
</ul>

<p>Running 5.07 km in 31m47s</p>

<ul>
  <li>Tuesday</li>
</ul>

<p>(1.5h) ConvexHull(by “Divide and Conquer”): design framework and solve the ostream operation of point2<T>.
Running 5.07 km in 31m35s</T></p>

<ul>
  <li>Wednesday</li>
</ul>

<p>leetcode top100: 1/100
(3h) ConvexHull(by “Divide and Conquer”): finishing(but have no document)!</p>

<ul>
  <li>Thursday</li>
</ul>

<p>Welcome my new laptop!</p>

<ul>
  <li>Friday</li>
</ul>

<p>Installing double systems and applications for working.
Running 5.01 km in 37m48s</p>

<ul>
  <li>Saturday</li>
</ul>

<p>6.046 Lecture 03: Divide and Conquer FFT</p>

<ul>
  <li>Sunday</li>
</ul>

<p>6.046 Lecture 04: Divide and Conquer van Emde Boas Tree</p>

<ul>
  <li>Summary</li>
</ul>

<p><a href="https://zhengtongdu.github.io/2022/10/31/Week_008_Record/">See last week’s record</a></p>

<p><a href="https://zhengtongdu.github.io/2022/11/14/Week_010_Record/">See next week’s record</a></p>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="research_record" /><summary type="html"><![CDATA[My week’s record during postgraduate period.]]></summary></entry><entry><title type="html">Week_008 Record</title><link href="http://localhost:4000/2022/10/31/Week_008_Record/" rel="alternate" type="text/html" title="Week_008 Record" /><published>2022-10-31T09:51:00+08:00</published><updated>2022-10-31T09:51:00+08:00</updated><id>http://localhost:4000/2022/10/31/Week_008_Record</id><content type="html" xml:base="http://localhost:4000/2022/10/31/Week_008_Record/"><![CDATA[<p>My  week’s record during postgraduate period.</p>

<ul>
  <li>Monday</li>
</ul>

<p>The begining of program design: Arithmetic Caculator, thinking how to design for 2h</p>

<ul>
  <li>Tuesday</li>
</ul>

<p>(4h) ArithmeticCaculator Design: finish subroutine: split expression into vector of strings.</p>

<p>Running 5.09 km in 32m08s</p>

<ul>
  <li>Wednesday</li>
</ul>

<p>(6h) ArithmeticCaculator Design: finish subroutine: generate list contains different types of elements.</p>

<ul>
  <li>Thursday</li>
</ul>

<p>(9h) ArithmeticCaculator Design: finish programming.</p>

<p>Running 5.05 km in 31m58s</p>

<ul>
  <li>Friday</li>
</ul>

<p>Attending two conferences.</p>

<ul>
  <li>Saturday</li>
</ul>

<p>Relaxation.</p>

<ul>
  <li>Sunday</li>
</ul>

<p>Doing midterm homework.</p>

<ul>
  <li>Summary</li>
</ul>

<p><a href="https://zhengtongdu.github.io/2022/10/24/Week_007_Record/">See last week’s record</a></p>

<p><a href="https://zhengtongdu.github.io/2022/11/07/Week_009_Record/">See next week’s record</a></p>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="research_record" /><summary type="html"><![CDATA[My week’s record during postgraduate period.]]></summary></entry><entry><title type="html">Week_007 Record</title><link href="http://localhost:4000/2022/10/24/Week_007_Record/" rel="alternate" type="text/html" title="Week_007 Record" /><published>2022-10-24T16:08:00+08:00</published><updated>2022-10-24T16:08:00+08:00</updated><id>http://localhost:4000/2022/10/24/Week_007_Record</id><content type="html" xml:base="http://localhost:4000/2022/10/24/Week_007_Record/"><![CDATA[<p>My  week’s record during postgraduate period.</p>
<ul>
  <li>
    <p>Monday</p>
  </li>
  <li>
    <p>Tuesday</p>
  </li>
</ul>

<p>Running 5.14 km in 33m10s</p>

<ul>
  <li>
    <p>Wednesday</p>
  </li>
  <li>
    <p>Thursday</p>
  </li>
  <li>
    <p>Friday</p>
  </li>
  <li>
    <p>Saturday</p>
  </li>
  <li>
    <p>Sunday</p>
  </li>
</ul>

<p>Running 5.02 km in 31m26s</p>

<ul>
  <li>Summary</li>
</ul>

<p>This week I did few things about research due to lots of mid-term homework and other useless things:(.</p>

<p><a href="https://zhengtongdu.github.io/2022/10/17/Week_006_Record/">See last week’s record</a></p>

<p><a href="https://zhengtongdu.github.io/2022/10/31/Week_008_Record/">See next week’s record</a></p>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="research_record" /><summary type="html"><![CDATA[My week’s record during postgraduate period. Monday]]></summary></entry><entry><title type="html">Week_006 Record</title><link href="http://localhost:4000/2022/10/17/Week_006_Record/" rel="alternate" type="text/html" title="Week_006 Record" /><published>2022-10-17T18:13:00+08:00</published><updated>2022-10-17T18:13:00+08:00</updated><id>http://localhost:4000/2022/10/17/Week_006_Record</id><content type="html" xml:base="http://localhost:4000/2022/10/17/Week_006_Record/"><![CDATA[<p>My  week’s record during postgraduate period.</p>

<ul>
  <li>Monday</li>
</ul>

<p>Effective Modern C++: Stop at Item 4</p>

<ul>
  <li>Tuesday</li>
</ul>

<p>Effective Modern C++: Stop at Item 6</p>

<p>PBRT: Stop at 2.7: Transformation</p>

<ul>
  <li>Wednesday</li>
</ul>

<p>Effective Modern C++: Stop at Item 9</p>

<p>Running 5.01 km in 33m17s</p>

<ul>
  <li>Thursday</li>
</ul>

<p>Effective Modern C++: Stop at Item 12</p>

<ul>
  <li>Friday</li>
</ul>

<p>Effective Modern C++: Stop at Item 15</p>

<ul>
  <li>
    <p>Saturday</p>
  </li>
  <li>
    <p>Sunday</p>
  </li>
</ul>

<p>Effective Modern C++: Stop at Item 18
Running 5.11 km in 35m15s</p>

<ul>
  <li>Summary</li>
</ul>

<p><a href="https://zhengtongdu.github.io/2022/10/10/Week_005_Record/">See last week’s record</a></p>

<p><a href="https://zhengtongdu.github.io/2022/10/24/Week_007_Record/">See next week’s record</a></p>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="research_record" /><summary type="html"><![CDATA[My week’s record during postgraduate period.]]></summary></entry></feed>