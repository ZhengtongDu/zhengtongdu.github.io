<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-02-28T19:17:30+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Zhengtong’s blog</title><subtitle>learn&amp;record&amp;share</subtitle><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><entry><title type="html">Design_Documentation01</title><link href="http://localhost:4000/2023/02/28/Design_Document01/" rel="alternate" type="text/html" title="Design_Documentation01" /><published>2023-02-28T13:46:00+08:00</published><updated>2023-02-28T13:46:00+08:00</updated><id>http://localhost:4000/2023/02/28/Design_Document01</id><content type="html" xml:base="http://localhost:4000/2023/02/28/Design_Document01/"><![CDATA[<blockquote>
  <p>整理了自己写的一些算法实现的设计思路</p>
</blockquote>

<h2 id="delaunay-triangulation">Delaunay Triangulation</h2>

<blockquote>
  <p>理论及算法的介绍：请参见<a href="https://zhengtongdu.github.io/2023/01/14/Computational_Geometry_notes_01/">这里</a></p>
</blockquote>

<p>程序最后实现了如下目标：对于输入的散点（通过触发鼠标事件或者在main.cpp中设定）：
<img src="/assets/23-02-28-fig01.png" alt="fig01: scattered points" height="300px" width="300px" /></p>

<p>生成其对应的Delaunay三角剖分网格：
<img src="/assets/23-02-28-fig02.png" alt="fig02: delaunay triangulation of above points" height="300px" width="300px" /></p>

<h3 id="设计1底层类的设计">设计1：底层类的设计</h3>

<p>底层类中定义了Vector类、Triangle类</p>

<h3 id="设计2画图api的调用">设计2：画图API的调用</h3>

<p>这部分的内容仿照的是GAMES101</p>

<h3 id="代码结构03">代码结构03</h3>

<h3 id="经验教训收获">经验教训收获</h3>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="Learning Notes" /><category term="Design Document" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Design_document01</title><link href="http://localhost:4000/2023/02/28/Design_Document01/" rel="alternate" type="text/html" title="Design_document01" /><published>2023-02-28T00:00:00+08:00</published><updated>2023-02-28T00:00:00+08:00</updated><id>http://localhost:4000/2023/02/28/Design_Document01</id><content type="html" xml:base="http://localhost:4000/2023/02/28/Design_Document01/"><![CDATA[<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Delaunay Triangulation</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension bierner.markdown-preview-github-styles */
html,
body,
.github-markdown-body {
    padding: 0 !important;
    max-width: auto !important;
}

.github-markdown-body {
    background-color: var(--color-canvas-default);
    color: var(--color-fg-default);
}

.github-markdown-body {
    border: 1px solid transparent;
    box-sizing: border-box;
    margin: 0 auto;
    width: 100% !important;
}

.github-markdown-content {
    padding: 32px !important;
    max-width: 980px;
    min-width: 200px;
    margin: 0 auto;
}


.vscode-body.scrollBeyondLastLine {
    margin-bottom: 0;
}
.vscode-body.scrollBeyondLastLine .github-markdown-body {
    padding-bottom: calc(100vh + 10px) !important;
}

.github-markdown-body blockquote {
    background-color: initial;
}

.github-markdown-body pre {
    color: initial;
}

.github-markdown-body code {
    color: inherit;
}

.github-markdown-body pre code {
    color: initial;
}

.github-markdown-body code > div {
    background: none
}

.github-markdown-body.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.github-markdown-body p,
.github-markdown-body blockquote,
.github-markdown-body ul,
.github-markdown-body ol,
.github-markdown-body dl,
.github-markdown-body table,
.github-markdown-body pre {
  margin-top: 16px;
  margin-bottom: 16px;
}

/* Generated from 'node_modules/github-markdown-css/github-markdown.css' */

.github-markdown-light,
.vscode-body.vscode-light .github-markdown-auto {
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #8250df;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #FFEBE9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-danger-fg: #cf222e;
}

.github-markdown-dark,
.vscode-body.vscode-dark .github-markdown-auto {
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #484f58;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-danger-fg: #f85149;
}

@media (prefers-color-scheme: dark) {
  .github-markdown-system {
    color-scheme: dark;
    --color-prettylights-syntax-comment: #8b949e;
    --color-prettylights-syntax-constant: #79c0ff;
    --color-prettylights-syntax-entity: #d2a8ff;
    --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
    --color-prettylights-syntax-entity-tag: #7ee787;
    --color-prettylights-syntax-keyword: #ff7b72;
    --color-prettylights-syntax-string: #a5d6ff;
    --color-prettylights-syntax-variable: #ffa657;
    --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
    --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
    --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
    --color-prettylights-syntax-carriage-return-text: #f0f6fc;
    --color-prettylights-syntax-carriage-return-bg: #b62324;
    --color-prettylights-syntax-string-regexp: #7ee787;
    --color-prettylights-syntax-markup-list: #f2cc60;
    --color-prettylights-syntax-markup-heading: #1f6feb;
    --color-prettylights-syntax-markup-italic: #c9d1d9;
    --color-prettylights-syntax-markup-bold: #c9d1d9;
    --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
    --color-prettylights-syntax-markup-deleted-bg: #67060c;
    --color-prettylights-syntax-markup-inserted-text: #aff5b4;
    --color-prettylights-syntax-markup-inserted-bg: #033a16;
    --color-prettylights-syntax-markup-changed-text: #ffdfb6;
    --color-prettylights-syntax-markup-changed-bg: #5a1e02;
    --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
    --color-prettylights-syntax-markup-ignored-bg: #1158c7;
    --color-prettylights-syntax-meta-diff-range: #d2a8ff;
    --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
    --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
    --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
    --color-fg-default: #c9d1d9;
    --color-fg-muted: #8b949e;
    --color-fg-subtle: #484f58;
    --color-canvas-default: #0d1117;
    --color-canvas-subtle: #161b22;
    --color-border-default: #30363d;
    --color-border-muted: #21262d;
    --color-neutral-muted: rgba(110,118,129,0.4);
    --color-accent-fg: #58a6ff;
    --color-accent-emphasis: #1f6feb;
    --color-danger-fg: #f85149;
  }
}

@media (prefers-color-scheme: light) {
  .github-markdown-system {
    color-scheme: light;
    --color-prettylights-syntax-comment: #6e7781;
    --color-prettylights-syntax-constant: #0550ae;
    --color-prettylights-syntax-entity: #8250df;
    --color-prettylights-syntax-storage-modifier-import: #24292f;
    --color-prettylights-syntax-entity-tag: #116329;
    --color-prettylights-syntax-keyword: #cf222e;
    --color-prettylights-syntax-string: #0a3069;
    --color-prettylights-syntax-variable: #953800;
    --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
    --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
    --color-prettylights-syntax-invalid-illegal-bg: #82071e;
    --color-prettylights-syntax-carriage-return-text: #f6f8fa;
    --color-prettylights-syntax-carriage-return-bg: #cf222e;
    --color-prettylights-syntax-string-regexp: #116329;
    --color-prettylights-syntax-markup-list: #3b2300;
    --color-prettylights-syntax-markup-heading: #0550ae;
    --color-prettylights-syntax-markup-italic: #24292f;
    --color-prettylights-syntax-markup-bold: #24292f;
    --color-prettylights-syntax-markup-deleted-text: #82071e;
    --color-prettylights-syntax-markup-deleted-bg: #FFEBE9;
    --color-prettylights-syntax-markup-inserted-text: #116329;
    --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
    --color-prettylights-syntax-markup-changed-text: #953800;
    --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
    --color-prettylights-syntax-markup-ignored-text: #eaeef2;
    --color-prettylights-syntax-markup-ignored-bg: #0550ae;
    --color-prettylights-syntax-meta-diff-range: #8250df;
    --color-prettylights-syntax-brackethighlighter-angle: #57606a;
    --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
    --color-prettylights-syntax-constant-other-reference-link: #0a3069;
    --color-fg-default: #24292f;
    --color-fg-muted: #57606a;
    --color-fg-subtle: #6e7781;
    --color-canvas-default: #ffffff;
    --color-canvas-subtle: #f6f8fa;
    --color-border-default: #d0d7de;
    --color-border-muted: hsla(210,18%,87%,1);
    --color-neutral-muted: rgba(175,184,193,0.2);
    --color-accent-fg: #0969da;
    --color-accent-emphasis: #0969da;
    --color-danger-fg: #cf222e;
  }
}

.github-markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  margin: 0;
  color: var(--color-fg-default);
  background-color: var(--color-canvas-default);
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.github-markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.github-markdown-body h1:hover .anchor .octicon-link:before,
.github-markdown-body h2:hover .anchor .octicon-link:before,
.github-markdown-body h3:hover .anchor .octicon-link:before,
.github-markdown-body h4:hover .anchor .octicon-link:before,
.github-markdown-body h5:hover .anchor .octicon-link:before,
.github-markdown-body h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-color: currentColor;
  -webkit-mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
  mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
}

.github-markdown-body details,
.github-markdown-body figcaption,
.github-markdown-body figure {
  display: block;
}

.github-markdown-body summary {
  display: list-item;
}

.github-markdown-body a {
  background-color: transparent;
  color: var(--color-accent-fg);
  text-decoration: none;
}

.github-markdown-body a:active,
.github-markdown-body a:hover {
  outline-width: 0;
}

.github-markdown-body abbr[title] {
  border-bottom: none;
  -webkit-text-decoration: underline dotted;
  text-decoration: underline dotted;
}

.github-markdown-body b,
.github-markdown-body strong {
  font-weight: 600;
}

.github-markdown-body dfn {
  font-style: italic;
}

.github-markdown-body h1 {
  margin: .67em 0;
  font-weight: 600;
  padding-bottom: .3em;
  font-size: 2em;
  border-bottom: 1px solid var(--color-border-muted);
}

.github-markdown-body mark {
  background-color: #ff0;
  color: var(--color-text-primary);
}

.github-markdown-body small {
  font-size: 90%;
}

.github-markdown-body sub,
.github-markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

.github-markdown-body sub {
  bottom: -0.25em;
}

.github-markdown-body sup {
  top: -0.5em;
}

.github-markdown-body img {
  border-style: none;
  max-width: 100%;
  box-sizing: content-box;
  background-color: var(--color-canvas-default);
}

.github-markdown-body code,
.github-markdown-body kbd,
.github-markdown-body pre,
.github-markdown-body samp {
  font-family: monospace,monospace;
  font-size: 1em;
}

.github-markdown-body figure {
  margin: 1em 40px;
}

.github-markdown-body hr {
  box-sizing: content-box;
  overflow: hidden;
  background: transparent;
  border-bottom: 1px solid var(--color-border-muted);
  height: .25em;
  padding: 0;
  margin: 24px 0;
  background-color: var(--color-border-default);
  border: 0;
}

.github-markdown-body html [type=button],
.github-markdown-body [type=reset],
.github-markdown-body [type=submit] {
  -webkit-appearance: button;
}

.github-markdown-body [type=button]::-moz-focus-inner,
.github-markdown-body [type=reset]::-moz-focus-inner,
.github-markdown-body [type=submit]::-moz-focus-inner {
  border-style: none;
  padding: 0;
}

.github-markdown-body [type=button]:-moz-focusring,
.github-markdown-body [type=reset]:-moz-focusring,
.github-markdown-body [type=submit]:-moz-focusring {
  outline: 1px dotted ButtonText;
}

.github-markdown-body [type=checkbox],
.github-markdown-body [type=radio] {
  box-sizing: border-box;
  padding: 0;
}

.github-markdown-body [type=number]::-webkit-inner-spin-button,
.github-markdown-body [type=number]::-webkit-outer-spin-button {
  height: auto;
}

.github-markdown-body [type=search] {
  -webkit-appearance: textfield;
  outline-offset: -2px;
}

.github-markdown-body [type=search]::-webkit-search-cancel-button,
.github-markdown-body [type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
}

.github-markdown-body ::-webkit-input-placeholder {
  color: inherit;
  opacity: .54;
}

.github-markdown-body ::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}

.github-markdown-body a:hover {
  text-decoration: underline;
}

.github-markdown-body hr::before {
  display: table;
  content: "";
}

.github-markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.github-markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
  display: block;
  width: max-content;
  max-width: 100%;
  overflow: auto;
}

.github-markdown-body td,
.github-markdown-body th {
  padding: 0;
}

.github-markdown-body details summary {
  cursor: pointer;
}

.github-markdown-body details:not([open])>*:not(summary) {
  display: none !important;
}

.github-markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  line-height: 10px;
  color: var(--color-fg-default);
  vertical-align: middle;
  background-color: var(--color-canvas-subtle);
  border: solid 1px var(--color-neutral-muted);
  border-bottom-color: var(--color-neutral-muted);
  border-radius: 6px;
  box-shadow: inset 0 -1px 0 var(--color-neutral-muted);
}

.github-markdown-body h1,
.github-markdown-body h2,
.github-markdown-body h3,
.github-markdown-body h4,
.github-markdown-body h5,
.github-markdown-body h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

.github-markdown-body h2 {
  font-weight: 600;
  padding-bottom: .3em;
  font-size: 1.5em;
  border-bottom: 1px solid var(--color-border-muted);
}

.github-markdown-body h3 {
  font-weight: 600;
  font-size: 1.25em;
}

.github-markdown-body h4 {
  font-weight: 600;
  font-size: 1em;
}

.github-markdown-body h5 {
  font-weight: 600;
  font-size: .875em;
}

.github-markdown-body h6 {
  font-weight: 600;
  font-size: .85em;
  color: var(--color-fg-muted);
}

.github-markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.github-markdown-body blockquote {
  margin: 0;
  padding: 0 1em;
  color: var(--color-fg-muted);
  border-left: .25em solid var(--color-border-default);
}

.github-markdown-body ul,
.github-markdown-body ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 2em;
}

.github-markdown-body ol ol,
.github-markdown-body ul ol {
  list-style-type: lower-roman;
}

.github-markdown-body ul ul ol,
.github-markdown-body ul ol ol,
.github-markdown-body ol ul ol,
.github-markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.github-markdown-body dd {
  margin-left: 0;
}

.github-markdown-body tt,
.github-markdown-body code {
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
}

.github-markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
  word-wrap: normal;
}

.github-markdown-body :-ms-input-placeholder {
  color: var(--color-fg-subtle);
  opacity: 1;
}

.github-markdown-body ::-ms-input-placeholder {
  color: var(--color-fg-subtle);
  opacity: 1;
}

.github-markdown-body ::placeholder {
  color: var(--color-fg-subtle);
  opacity: 1;
}

.github-markdown-body .pl-c {
  color: var(--color-prettylights-syntax-comment);
}

.github-markdown-body .pl-c1,
.github-markdown-body .pl-s .pl-v {
  color: var(--color-prettylights-syntax-constant);
}

.github-markdown-body .pl-e,
.github-markdown-body .pl-en {
  color: var(--color-prettylights-syntax-entity);
}

.github-markdown-body .pl-smi,
.github-markdown-body .pl-s .pl-s1 {
  color: var(--color-prettylights-syntax-storage-modifier-import);
}

.github-markdown-body .pl-ent {
  color: var(--color-prettylights-syntax-entity-tag);
}

.github-markdown-body .pl-k {
  color: var(--color-prettylights-syntax-keyword);
}

.github-markdown-body .pl-s,
.github-markdown-body .pl-pds,
.github-markdown-body .pl-s .pl-pse .pl-s1,
.github-markdown-body .pl-sr,
.github-markdown-body .pl-sr .pl-cce,
.github-markdown-body .pl-sr .pl-sre,
.github-markdown-body .pl-sr .pl-sra {
  color: var(--color-prettylights-syntax-string);
}

.github-markdown-body .pl-v,
.github-markdown-body .pl-smw {
  color: var(--color-prettylights-syntax-variable);
}

.github-markdown-body .pl-bu {
  color: var(--color-prettylights-syntax-brackethighlighter-unmatched);
}

.github-markdown-body .pl-ii {
  color: var(--color-prettylights-syntax-invalid-illegal-text);
  background-color: var(--color-prettylights-syntax-invalid-illegal-bg);
}

.github-markdown-body .pl-c2 {
  color: var(--color-prettylights-syntax-carriage-return-text);
  background-color: var(--color-prettylights-syntax-carriage-return-bg);
}

.github-markdown-body .pl-sr .pl-cce {
  font-weight: bold;
  color: var(--color-prettylights-syntax-string-regexp);
}

.github-markdown-body .pl-ml {
  color: var(--color-prettylights-syntax-markup-list);
}

.github-markdown-body .pl-mh,
.github-markdown-body .pl-mh .pl-en,
.github-markdown-body .pl-ms {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-heading);
}

.github-markdown-body .pl-mi {
  font-style: italic;
  color: var(--color-prettylights-syntax-markup-italic);
}

.github-markdown-body .pl-mb {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-bold);
}

.github-markdown-body .pl-md {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

.github-markdown-body .pl-mi1 {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.github-markdown-body .pl-mc {
  color: var(--color-prettylights-syntax-markup-changed-text);
  background-color: var(--color-prettylights-syntax-markup-changed-bg);
}

.github-markdown-body .pl-mi2 {
  color: var(--color-prettylights-syntax-markup-ignored-text);
  background-color: var(--color-prettylights-syntax-markup-ignored-bg);
}

.github-markdown-body .pl-mdr {
  font-weight: bold;
  color: var(--color-prettylights-syntax-meta-diff-range);
}

.github-markdown-body .pl-ba {
  color: var(--color-prettylights-syntax-brackethighlighter-angle);
}

.github-markdown-body .pl-sg {
  color: var(--color-prettylights-syntax-sublimelinter-gutter-mark);
}

.github-markdown-body .pl-corl {
  text-decoration: underline;
  color: var(--color-prettylights-syntax-constant-other-reference-link);
}

.github-markdown-body [data-catalyst] {
  display: block;
}

.github-markdown-body g-emoji {
  font-family: "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 1em;
  font-style: normal !important;
  font-weight: 400;
  line-height: 1;
  vertical-align: -0.075em;
}

.github-markdown-body g-emoji img {
  width: 1em;
  height: 1em;
}

.github-markdown-body::before {
  display: table;
  content: "";
}

.github-markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.github-markdown-body>*:first-child {
  margin-top: 0 !important;
}

.github-markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.github-markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.github-markdown-body .absent {
  color: var(--color-danger-fg);
}

.github-markdown-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}

.github-markdown-body .anchor:focus {
  outline: none;
}

.github-markdown-body p,
.github-markdown-body blockquote,
.github-markdown-body ul,
.github-markdown-body ol,
.github-markdown-body dl,
.github-markdown-body table,
.github-markdown-body pre,
.github-markdown-body details {
  margin-top: 0;
  margin-bottom: 16px;
}

.github-markdown-body blockquote>:first-child {
  margin-top: 0;
}

.github-markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.github-markdown-body sup>a::before {
  content: "[";
}

.github-markdown-body sup>a::after {
  content: "]";
}

.github-markdown-body h1 .octicon-link,
.github-markdown-body h2 .octicon-link,
.github-markdown-body h3 .octicon-link,
.github-markdown-body h4 .octicon-link,
.github-markdown-body h5 .octicon-link,
.github-markdown-body h6 .octicon-link {
  color: var(--color-fg-default);
  vertical-align: middle;
  visibility: hidden;
}

.github-markdown-body h1:hover .anchor,
.github-markdown-body h2:hover .anchor,
.github-markdown-body h3:hover .anchor,
.github-markdown-body h4:hover .anchor,
.github-markdown-body h5:hover .anchor,
.github-markdown-body h6:hover .anchor {
  text-decoration: none;
}

.github-markdown-body h1:hover .anchor .octicon-link,
.github-markdown-body h2:hover .anchor .octicon-link,
.github-markdown-body h3:hover .anchor .octicon-link,
.github-markdown-body h4:hover .anchor .octicon-link,
.github-markdown-body h5:hover .anchor .octicon-link,
.github-markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.github-markdown-body h1 tt,
.github-markdown-body h1 code,
.github-markdown-body h2 tt,
.github-markdown-body h2 code,
.github-markdown-body h3 tt,
.github-markdown-body h3 code,
.github-markdown-body h4 tt,
.github-markdown-body h4 code,
.github-markdown-body h5 tt,
.github-markdown-body h5 code,
.github-markdown-body h6 tt,
.github-markdown-body h6 code {
  padding: 0 .2em;
  font-size: inherit;
}

.github-markdown-body ul.no-list,
.github-markdown-body ol.no-list {
  padding: 0;
  list-style-type: none;
}

.github-markdown-body ol[type="1"] {
  list-style-type: decimal;
}

.github-markdown-body ol[type=a] {
  list-style-type: lower-alpha;
}

.github-markdown-body ol[type=i] {
  list-style-type: lower-roman;
}

.github-markdown-body div>ol:not([type]) {
  list-style-type: decimal;
}

.github-markdown-body ul ul,
.github-markdown-body ul ol,
.github-markdown-body ol ol,
.github-markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.github-markdown-body li>p {
  margin-top: 16px;
}

.github-markdown-body li+li {
  margin-top: .25em;
}

.github-markdown-body dl {
  padding: 0;
}

.github-markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
}

.github-markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.github-markdown-body table th {
  font-weight: 600;
}

.github-markdown-body table th,
.github-markdown-body table td {
  padding: 6px 13px;
  border: 1px solid var(--color-border-default);
}

.github-markdown-body table tr {
  background-color: var(--color-canvas-default);
  border-top: 1px solid var(--color-border-muted);
}

.github-markdown-body table tr:nth-child(2n) {
  background-color: var(--color-canvas-subtle);
}

.github-markdown-body table img {
  background-color: transparent;
}

.github-markdown-body img[align=right] {
  padding-left: 20px;
}

.github-markdown-body img[align=left] {
  padding-right: 20px;
}

.github-markdown-body .emoji {
  max-width: none;
  vertical-align: text-top;
  background-color: transparent;
}

.github-markdown-body span.frame {
  display: block;
  overflow: hidden;
}

.github-markdown-body span.frame>span {
  display: block;
  float: left;
  width: auto;
  padding: 7px;
  margin: 13px 0 0;
  overflow: hidden;
  border: 1px solid var(--color-border-default);
}

.github-markdown-body span.frame span img {
  display: block;
  float: left;
}

.github-markdown-body span.frame span span {
  display: block;
  padding: 5px 0 0;
  clear: both;
  color: var(--color-fg-default);
}

.github-markdown-body span.align-center {
  display: block;
  overflow: hidden;
  clear: both;
}

.github-markdown-body span.align-center>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: center;
}

.github-markdown-body span.align-center span img {
  margin: 0 auto;
  text-align: center;
}

.github-markdown-body span.align-right {
  display: block;
  overflow: hidden;
  clear: both;
}

.github-markdown-body span.align-right>span {
  display: block;
  margin: 13px 0 0;
  overflow: hidden;
  text-align: right;
}

.github-markdown-body span.align-right span img {
  margin: 0;
  text-align: right;
}

.github-markdown-body span.float-left {
  display: block;
  float: left;
  margin-right: 13px;
  overflow: hidden;
}

.github-markdown-body span.float-left span {
  margin: 13px 0 0;
}

.github-markdown-body span.float-right {
  display: block;
  float: right;
  margin-left: 13px;
  overflow: hidden;
}

.github-markdown-body span.float-right>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: right;
}

.github-markdown-body code,
.github-markdown-body tt {
  padding: .2em .4em;
  margin: 0;
  font-size: 85%;
  background-color: var(--color-neutral-muted);
  border-radius: 6px;
}

.github-markdown-body code br,
.github-markdown-body tt br {
  display: none;
}

.github-markdown-body del code {
  text-decoration: inherit;
}

.github-markdown-body pre code {
  font-size: 100%;
}

.github-markdown-body pre>code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.github-markdown-body .highlight {
  margin-bottom: 16px;
}

.github-markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.github-markdown-body .highlight pre,
.github-markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: var(--color-canvas-subtle);
  border-radius: 6px;
}

.github-markdown-body pre code,
.github-markdown-body pre tt {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.github-markdown-body .csv-data td,
.github-markdown-body .csv-data th {
  padding: 5px;
  overflow: hidden;
  font-size: 12px;
  line-height: 1;
  text-align: left;
  white-space: nowrap;
}

.github-markdown-body .csv-data .blob-num {
  padding: 10px 8px 9px;
  text-align: right;
  background: var(--color-canvas-default);
  border: 0;
}

.github-markdown-body .csv-data tr {
  border-top: 0;
}

.github-markdown-body .csv-data th {
  font-weight: 600;
  background: var(--color-canvas-subtle);
  border-top: 0;
}

.github-markdown-body .footnotes {
  font-size: 12px;
  color: var(--color-fg-muted);
  border-top: 1px solid var(--color-border-default);
}

.github-markdown-body .footnotes ol {
  padding-left: 16px;
}

.github-markdown-body .footnotes li {
  position: relative;
}

.github-markdown-body .footnotes li:target::before {
  position: absolute;
  top: -8px;
  right: -8px;
  bottom: -8px;
  left: -24px;
  pointer-events: none;
  content: "";
  border: 2px solid var(--color-accent-emphasis);
  border-radius: 6px;
}

.github-markdown-body .footnotes li:target {
  color: var(--color-fg-default);
}

.github-markdown-body .footnotes .data-footnote-backref g-emoji {
  font-family: monospace;
}

.github-markdown-body [hidden] {
  display: none !important;
}

.github-markdown-body ::-webkit-calendar-picker-indicator {
  filter: invert(50%);
}
/*!
  Theme: GitHub
  Description: Highlight-js port of github.com theme
  Author: github.com
  Maintainer: @SNDST00M, @mjbvz
  Updated: 2021-12-08
*/
.markdown-body pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 16px;
}

.markdown-body code.hljs {
  padding: 3px 5px;
}

/*!
  Theme: GitHub
  Description: Theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/
.markdown-body .hljs {
  color: var(--color-fg-default);
  background: var(--color-canvas-subtle);
}

.markdown-body .hljs-doctag,
.markdown-body .hljs-keyword,
.markdown-body .hljs-meta .hljs-keyword,
.markdown-body .hljs-template-tag,
.markdown-body .hljs-template-variable,
.markdown-body .hljs-type,
.markdown-body .hljs-variable.language_ {
  color: var(--color-prettylights-syntax-keyword);
}

.markdown-body .hljs-title,
.markdown-body .hljs-title.class_,
.markdown-body .hljs-title.class_.inherited__,
.markdown-body .hljs-title.function_ {
  color: var(--color-prettylights-syntax-entity);
}

.markdown-body .hljs-attr,
.markdown-body .hljs-attribute,
.markdown-body .hljs-literal,
.markdown-body .hljs-meta,
.markdown-body .hljs-number,
.markdown-body .hljs-operator,
.markdown-body .hljs-selector-attr,
.markdown-body .hljs-selector-class,
.markdown-body .hljs-selector-id,
.markdown-body .hljs-variable {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .hljs-meta .hljs-string,
.markdown-body .hljs-regexp,
.markdown-body .hljs-string {
  color: var(--color-prettylights-syntax-string);
}

.markdown-body .hljs-built_in,
.markdown-body .hljs-symbol {
  color: var(--color-prettylights-syntax-variable);
}

.markdown-body .hljs-code,
.markdown-body .hljs-comment,
.markdown-body .hljs-formula {
  color: var(--color-prettylights-syntax-comment);
}

.markdown-body .hljs-name,
.markdown-body .hljs-quote,
.markdown-body .hljs-selector-pseudo,
.markdown-body .hljs-selector-tag {
  color: var(--color-prettylights-syntax-entity-tag);
}

.markdown-body .hljs-subst {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .hljs-section {
  color: var(--color-prettylights-syntax-markup-heading);
  font-weight: bold;
}

.markdown-body .hljs-bullet {
  color: var(--color-prettylights-syntax-markup-list);
}

.markdown-body .hljs-emphasis {
  color: var(--color-prettylights-syntax-constant);
  font-style: italic;
}

.markdown-body .hljs-strong {
  color: var(--color-prettylights-syntax-constant);
  font-weight: bold;
}

.markdown-body .hljs-addition {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.markdown-body .hljs-deletion {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <div class="github-markdown-body github-markdown-auto">
            <div class="github-markdown-content"><hr>
<h2 id="layout-posttitle-design_documentation01date-2023-02-28-1346-0800tags-learning-notes-design-documenttoc-true">layout: post
title: Design_Documentation01
date: 2023-02-28 13:46 +0800
tags: [&quot;Learning Notes&quot;, &quot;Design Document&quot;]
toc: true</h2>
<blockquote>
<p>整理了自己写的一些算法实现的设计思路</p>
</blockquote>
<h2 id="delaunay-triangulation">Delaunay Triangulation</h2>
<blockquote>
<p>理论及算法的介绍：请参见<a href="https://zhengtongdu.github.io/2023/01/14/Computational_Geometry_notes_01/">这里</a></p>
</blockquote>
<p>程序最后实现了如下目标：对于输入的散点（通过触发鼠标事件或者在main.cpp中设定）：
<img src="file:////assets/23-02-28-fig01.png" alt="fig01: scattered points">{:height=&quot;300px&quot; width=&quot;300px&quot;}</p>
<p>生成其对应的Delaunay三角剖分网格：
<img src="file:////assets/23-02-28-fig02.png" alt="fig02: delaunay triangulation of above points">{:height=&quot;300px&quot; width=&quot;300px&quot;}</p>
<h3 id="设计1底层类的设计">设计1：底层类的设计</h3>
<p>底层类中定义了Vector类、Triangle类</p>
<h3 id="设计2画图api的调用">设计2：画图API的调用</h3>
<p>这部分的内容仿照的是GAMES101</p>
<h3 id="代码结构03">代码结构03</h3>
<h3 id="经验教训收获">经验教训收获</h3>
</div>
        </div>
        
        
    </body>
    </html>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><summary type="html"><![CDATA[Delaunay Triangulation /* From extension vscode.github */ /*--------------------------------------------------------------------------------------------- * Copyright (c) Microsoft Corporation. All rights reserved. * Licensed under the MIT License. See License.txt in the project root for license information. *--------------------------------------------------------------------------------------------*/]]></summary></entry><entry><title type="html">GAMES101_notes_05</title><link href="http://localhost:4000/2023/02/13/GAMES101_notes_05/" rel="alternate" type="text/html" title="GAMES101_notes_05" /><published>2023-02-13T19:55:00+08:00</published><updated>2023-02-13T19:55:00+08:00</updated><id>http://localhost:4000/2023/02/13/GAMES101_notes_05</id><content type="html" xml:base="http://localhost:4000/2023/02/13/GAMES101_notes_05/"><![CDATA[<blockquote>
  <p>GAMES101: 现代计算机图形学入门</p>

  <p>笔记05:</p>
</blockquote>

<h2 id="lecture-17-materials-and-appearances">Lecture 17: Materials and Appearances</h2>

<p>What is Material in Computer Graphics?</p>

<h3 id="material--brdf">Material == BRDF</h3>

<h4 id="diffuse--lambertian-material-漫反射材质">Diffuse / Lambertian Material 漫反射材质</h4>

<p>Light is equally reflected in each output direction</p>

<ul>
  <li>Suppose the incident lighting is uniform:</li>
  <li>$L_o(\omega_o) = \int_{H^2}f_rL_i(\omega_i)\cos\theta_i\mathrm{d}\omega_i = f_rL_i\int_{H^2}\cos\theta_i\mathrm{d}\omega_i = \pi f_r L_i$</li>
  <li>$f_r = \frac{\rho}{\pi}$, 反射率$\rho$</li>
</ul>

<h4 id="glossy-material-类似金属的光滑材质">Glossy Material 类似金属的光滑材质</h4>

<h4 id="ideal-reflective--refractive-materialbsdf">Ideal reflective / refractive material(BSDF)</h4>

<p>Perfect Specular Reflection</p>

<ul>
  <li>$\omega_o + \omega_i = 2\cos\theta\vec{n} = 2 (\omega_i\cdot \vec{n})\vec{n}\quad \Rightarrow \quad \omega_o = -\omega_i + 2(\omega_i \cdot \vec{n})\vec{n}$</li>
</ul>

<p>Specular Refraction</p>

<ul>
  <li>In addition to reflecting off surface, light may be transmitted through surface.</li>
  <li>Light refracts when it enters a new medium</li>
</ul>

<p>Snell’s Law</p>

<ul>
  <li>Transmitted angle depends on
    <ul>
      <li>index of refraction(IOR) for incident ray</li>
      <li>IOR for exiting ray</li>
    </ul>
  </li>
  <li>$\eta_i\sin\theta_i = \eta_t\sin\theta_t$</li>
  <li>$\cos\theta_t = \sqrt{1 - (\frac{\eta_i}{\eta_t})^2(1 - \cos^2\theta_i)}$ 当入射介质折射率大于折射介质时，可能会发生全反射现象（Snell’s Window/Circle）</li>
</ul>

<p>Fresnel Reflection / Term 菲涅耳项</p>

<ul>
  <li>Reflectance depends on incident angle(and polarization of light)</li>
  <li>对于绝缘体，当入射角角度非常小的时候，反射的能量就非常小，当入射角接近90度时，几乎没有折射发生（大部分能量被反射）</li>
  <li>对于导体，其菲涅耳项与绝缘体不同，无论入射角方向如何，反射的能量都占大多数</li>
  <li>Approximate: Schlick’s approximation 对两种介质都有较好的近似
    <ul>
      <li>$R(\theta) = R_0 + (1 - R_0)(1 - \cos\theta)^5$</li>
      <li>$R_0 = \left(\frac{n_1 - n_2}{n_1 + n_2}\right)^2$ 基准反射率</li>
    </ul>
  </li>
</ul>

<h4 id="microfacet-material">Microfacet Material</h4>

<p>Microfacet Theory</p>

<ul>
  <li>Rough surface
    <ul>
      <li>Macroscale: flat &amp; rough 从远处看是材质</li>
      <li>Microscale: bumpy &amp; specular 从近处看是几何</li>
    </ul>
  </li>
  <li>Individual elements of surface act like mirrors
    <ul>
      <li>Known as Microfacets</li>
      <li>Each microfacet has its own normal</li>
    </ul>
  </li>
</ul>

<p>Microfacet BRDF</p>

<ul>
  <li>如果微表面各处法线在宏观上差别不大，那么就得到了glossy材质</li>
  <li>如果微表面各处法线在宏观上区别很大，那么就得到了漫反射材质</li>
</ul>

\[f(\mathbf{i}, \mathbf{o}) = \frac{\mathbf{F}(\mathbf{i}, \mathbf{h})\mathbf{G}(\mathbf{i}, \mathbf{o}, \mathbf{h})\mathbf{D}(\mathbf{h})}{4(\mathbf{n}, \mathbf{i})(\mathbf{n}, \mathbf{o})}\]

<h4 id="isotropicanisotropic-materialsbrdfs-各向同性各向异性">Isotropic/Anisotropic Materials(BRDFs) 各向同性/各向异性</h4>

<p>Key: <strong>directionality</strong> of underlying surface</p>

<h4 id="properties-of-brdfs">Properties of BRDFs</h4>

<ul>
  <li>Non-negativity
    <ul>
      <li>$f_r(\omega_i\rightarrow\omega_r)\ge 0$</li>
    </ul>
  </li>
  <li>Linearity
    <ul>
      <li>$L_r(p, \omega_r) = \int_{H^2}f_r(p, \omega_i\rightarrow \omega_r)L_i(p, \omega_i) \cos \theta_i\mathrm{d}\omega_i$</li>
    </ul>
  </li>
  <li>Reciprocity principle
    <ul>
      <li>$f_r(\omega_r\rightarrow\omega_i) = f_r(\omega_i\rightarrow \omega_r)$</li>
    </ul>
  </li>
  <li>Energy conservation
    <ul>
      <li>$\forall \omega_r,\quad \int_{H^2}f_r(p, \omega_i\rightarrow \omega_r)L_i(p, \omega_i) \cos \theta_i\mathrm{d}\omega_i \le 1$</li>
    </ul>
  </li>
  <li>Isotropic vs. anisotropic
    <ul>
      <li>If isotropic, $f_r(\theta_i, \phi_i; \theta_r, \phi_r) = f_r(\theta_i, \theta_r, \phi_r - \phi_i)$</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Then, from reciprocity, $f_r(\theta_i, \theta_r, \phi_r - \phi_i) = f_r(\theta_i, \theta_r, \phi_i - \phi_r) = f_r(\theta_i, \theta_r,</td>
              <td>\phi_r - \phi_i</td>
              <td>)$</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
</ul>

<h3 id="measuring-brdfs">Measuring BRDFs</h3>

<h2 id="lecture-18-advanced-topics-in-rendering">Lecture 18: Advanced Topics in Rendering</h2>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="Learning Notes" /><category term="GAMES101" /><summary type="html"><![CDATA[GAMES101: 现代计算机图形学入门 笔记05:]]></summary></entry><entry><title type="html">Computational_Geometry_notes_02</title><link href="http://localhost:4000/2023/02/11/Computational_Geometry_notes_02/" rel="alternate" type="text/html" title="Computational_Geometry_notes_02" /><published>2023-02-11T15:23:00+08:00</published><updated>2023-02-11T15:23:00+08:00</updated><id>http://localhost:4000/2023/02/11/Computational_Geometry_notes_02</id><content type="html" xml:base="http://localhost:4000/2023/02/11/Computational_Geometry_notes_02/"><![CDATA[<p>Lecture 07 Voronoi Diagrams</p>

<blockquote>
  <p>To solve the Post Office Problem</p>
</blockquote>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="learning" /><category term="Computational Geometry" /><summary type="html"><![CDATA[Lecture 07 Voronoi Diagrams]]></summary></entry><entry><title type="html">GAMES101_notes_04</title><link href="http://localhost:4000/2023/02/06/GAMES101_notes_04/" rel="alternate" type="text/html" title="GAMES101_notes_04" /><published>2023-02-06T23:32:00+08:00</published><updated>2023-02-06T23:32:00+08:00</updated><id>http://localhost:4000/2023/02/06/GAMES101_notes_04</id><content type="html" xml:base="http://localhost:4000/2023/02/06/GAMES101_notes_04/"><![CDATA[<blockquote>
  <p>GAMES101: 现代计算机图形学入门</p>

  <p>笔记04：Ray-Tracing</p>
</blockquote>

<h2 id="lecture-13-ray-tracing-1whitted-style-ray-tracing">Lecture 13 Ray Tracing 1(Whitted-Style Ray Tracing)</h2>

<h3 id="why-ray-tracing">Why Ray Tracing</h3>

<ul>
  <li>Rasterization couldn’t handle <strong>global</strong> effects well
    <ul>
      <li>(soft) shadows</li>
      <li>especially when the light bounces <strong>more than once</strong></li>
    </ul>
  </li>
  <li>Rasterization is fast, but directions is very slow
    <ul>
      <li>Rasterization: real-time, ray tracing: offline</li>
      <li>~10K CPU core hours to render one frame in production</li>
    </ul>
  </li>
</ul>

<h3 id="basic-ray-tracing-algorithm">Basic Ray Tracing Algorithm</h3>

<p>Three ideas about light rays</p>

<ol>
  <li>Light travels in straight lines(though this is wrong)</li>
  <li>Light rays do not “collide” with each other if they cross(though this is still wrong)</li>
  <li>Light rays travel from the light sources to the eye(but the physics is invariant under path reversal - reciprocity)</li>
</ol>

<h4 id="ray-casting">Ray Casting</h4>

<ol>
  <li>Generate an image by <strong>casting one ray per pixel</strong></li>
  <li>Check for shadows by <strong>sending a ray to the light</strong></li>
</ol>

<h4 id="recursivewhitted-style-ray-tracing">Recursive(Whitted-Style) Ray Tracing</h4>

<ul>
  <li>考虑每个从眼睛出发的光线到每个物体处发生的折射和反射的结果；</li>
  <li>对于每个折射和反射的结果，分别计算其到光源的点的着色结果，加总后得到最后的着色值</li>
  <li>每次折射后的结果都会发生一定的能量损耗</li>
</ul>

<h3 id="ray-surface-intersection">Ray-Surface Intersection</h3>

<p>Ray is defined by its origin and a direction vector</p>

\[\mathbf{r}(t) = \mathbf{o} + t\mathbf{d}, \quad 0 \le t &lt; \infty\]

<h4 id="ray-intersection-with-sphere">Ray Intersection With Sphere</h4>

\[\mathrm{Ray: } \mathbf{r}(t) = \mathbf{o} + t\mathbf{d}, \quad \\
    \mathrm{Sphere: } \mathbf{p} : (\mathbf{p} - \mathbf{c})^2 - R^2 = 0\]

<h4 id="ray-intersection-with-implicit-surface">Ray Intersection With Implicit Surface</h4>

\[\mathrm{Ray: }\quad \mathbf{r}(t) = \mathbf{o} + t\mathbf{d}, \quad \\
    \mathrm{General\ implicit\ surface: }\quad \mathbf{p} : f(\mathbf{p}) = 0\\
    \mathrm{Substitute\ ray\ equation: }\quad f(\mathbf{o} + t\mathbf{d}) = 0\]

<h4 id="ray-intersection-with-triangle-mesh">Ray Intersection With Triangle Mesh</h4>

<p>Why?</p>

<ul>
  <li>Rendering: visibility, shadows, lighting</li>
  <li>Geometry: inside/outside test</li>
</ul>

<p>How?</p>

<ul>
  <li>Simple idea: just intersect ray with each triangle</li>
  <li>Simple, but slow(acceleration? – later)</li>
  <li>Note: can have 0, 1 intersections(ignoring multiple intersections)</li>
</ul>

<h4 id="ray-intersection-with-triangle">Ray Intersection With Triangle</h4>

<p>Triangle is in a plane</p>

<ul>
  <li>Ray-plane intersection</li>
  <li>Test if hit point is inside triangle</li>
</ul>

<p>Plane is defined by normal vector and a point on plane</p>

\[\mathbf{p}: (\mathbf{p} - \mathbf{p}')\cdot\mathbf{N} = 0\qquad
    ax + by + cz + d = 0\]

<h4 id="moller-trumbore-algorithm">Moller Trumbore Algorithm</h4>

<p>A fast approach, giving barycentric coordinate directly</p>

<p>Derivation in the discussion section!</p>

\[\mathbf{O} + t\mathbf{D} = (1 - b_1 - b_2)\mathbf{P}_0 + b_1 \mathbf{P}_1 + b_2\mathbf{P}_2\]

<h3 id="accelerating-ray-surface-intersection">Accelerating Ray-Surface Intersection</h3>

<p>Simple ray-scene intersection</p>

<ul>
  <li>Exhaustively test ray-intersection with every object</li>
  <li>Find the closest hit(with minimum t)</li>
</ul>

<h4 id="bounding-volumes">Bounding Volumes</h4>

<p>Quick way to avoid intersections: bound complex object with a simple volume</p>

<ul>
  <li>Object is fully contained in the volume</li>
  <li>If it doesn’t hit the volume, it doesn’t hit the object</li>
  <li>So test BVol first, then test object if it hits</li>
</ul>

<p>Ray-Intersection with Box</p>

<ul>
  <li>Understanding: box is the intersection of 3 pairs of slabs</li>
  <li>Specifically, we often use an Axis-Aligned Bounding Box(AABB)</li>
</ul>

<p>Key ideas</p>

<ul>
  <li>The ray enters the box only when it enters all pairs of slabs</li>
  <li>The ray exits the bos as long as it exits any pair of slabs</li>
</ul>

<p>具体操作方法：</p>

<ul>
  <li>考虑光线通过分别通过每个方向的两个平面的时间$t_{\min},\ t_{\max}$</li>
  <li>如果进入时间的最大值小于射出时间的最小值，则说明光线同包围盒有交点</li>
  <li>对于时间为负值的情况
    <ul>
      <li>如果进入时间为负，离开时间为正，则可以说明光源在盒中；</li>
      <li>如果离开时间为负，说明盒子沿光路在光源后面</li>
    </ul>
  </li>
  <li>In summary, ray and AABB intersect iff
    <ul>
      <li>$t_{enter} &lt; t_{exit}\ \mathrm{and}\ t_{exit} \ge 0$</li>
    </ul>
  </li>
</ul>

<h2 id="lecture-14-ray-tracing-2acceleration--radiometry">Lecture 14 Ray Tracing 2(Acceleration &amp; Radiometry)</h2>

<p>本讲内容：</p>

<ul>
  <li>Using AABBs to accelerate ray tracing
    <ul>
      <li>Uniform grids</li>
      <li>Spatial partitions</li>
    </ul>
  </li>
  <li>Basic radiometry(辐射度量学)</li>
</ul>

<h3 id="uniform-spatial-partitionsgrids">Uniform Spatial Partitions(Grids)</h3>

<p>Preprocess - Build Acceleration Grid</p>

<ul>
  <li>Find bounding box</li>
  <li>Create grid</li>
  <li>Store each object in overlapping cells</li>
</ul>

<p>Step through grid in ray traversal order, for each grid cell test intersection with all objects stored at that cell.（类似分治的想法）</p>

<p>存在的问题：当场景中的物体分布过于稀疏的时候，会存在冗余运算的情况。</p>

<h3 id="spatial-partitions">Spatial Partitions</h3>

<p>Examples:</p>

<ul>
  <li>Oct-Tree 每次沿每个维度进行分割</li>
  <li>KD-Tree 每次只沿一个维度进行分割</li>
  <li>BSP-Tree 每次沿一个方向进行分割</li>
</ul>

<p>考虑到AABB的结构，采用KD-Tree是较为合适的解决方法</p>

<p>Data Structure for KD-Trees</p>

<ul>
  <li>Internal nodes store
    <ul>
      <li>split axis: x-, y- or z-axis</li>
      <li>split position: coordinate of split plane along axis</li>
      <li>children: pointers to child nodes</li>
      <li><strong>No objects are stored in internal nodes</strong></li>
    </ul>
  </li>
  <li>Leaf nodes store
    <ul>
      <li>list of objects</li>
    </ul>
  </li>
</ul>

<p>对于构建好的数据结构，只要进行遍历，判断光线经过每个结构时是否可能相交，就可以进行下一步的判断。</p>

<p>但是KD-Tree(还有八叉树)来说，还有如下两个问题难以解决：</p>

<ul>
  <li>同一个物体可能存在多个盒子里</li>
  <li>判断三角形是否和盒子相交很困难</li>
</ul>

<p>因此提出了如下的解决方法：</p>

<h3 id="object-partitions--bounding-volume-hierarchybvh">Object Partitions &amp; Bounding Volume Hierarchy(BVH)</h3>

<p>采取和KD-Tree相反的思路，不再对空间进行划分，而是对物体进行划分，然后构建新的子包围盒，这样得到的结构，虽然包围盒可能彼此相交且空间划分并不完全均匀，但是可以保证每个物体只存在于一个包围盒中，且不需要担心盒子和物体的相交问题（因为盒子是由包围关系确定的）</p>

<p>Summary: Building BVHs</p>

<ul>
  <li>Find bounding box</li>
  <li>Recursively split set of objects in two subsets</li>
  <li><strong>Recompute</strong> the bounding box of the subsets</li>
  <li>Stop when necessary</li>
  <li>Store objects in each leaf node</li>
</ul>

<p>细节问题：</p>

<ul>
  <li>How to subdivide a node?
    <ul>
      <li>Choose a dimension to split</li>
      <li>Heuristic #1: Always choose the longest axis in node（保证盒子尽可能是方的）</li>
      <li>Heuristic #2: Split node at location of <strong>median</strong> object</li>
    </ul>
  </li>
  <li>Termination criteria?
    <ul>
      <li>Heuristic: stop when node contains few elements(e.g. 5)</li>
    </ul>
  </li>
</ul>

<p>Data Structure for BVHs</p>

<ul>
  <li>Internal nodes store
    <ul>
      <li>Bounding box</li>
      <li>Children: pointers to child nodes</li>
    </ul>
  </li>
  <li>Leaf nodes store
    <ul>
      <li>Bounding box</li>
      <li>List of objects</li>
    </ul>
  </li>
  <li>Nodes represent subset of primitives in scene
    <ul>
      <li>All objects in subtree</li>
    </ul>
  </li>
</ul>

<p>BVH Traversal(pseudocode)</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Intersect</span><span class="p">(</span><span class="n">Ray</span> <span class="n">ray</span><span class="p">,</span> <span class="n">BVH</span> <span class="n">node</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">ray</span> <span class="n">misses</span> <span class="n">node</span><span class="p">.</span><span class="n">bbox</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="n">is</span> <span class="n">a</span> <span class="n">leaf</span> <span class="n">node</span><span class="p">)</span>
    <span class="n">test</span> <span class="n">intersection</span> <span class="n">with</span> <span class="n">all</span> <span class="n">objs</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">closest</span> <span class="n">intersection</span><span class="p">;</span>

  <span class="n">hit1</span> <span class="o">=</span> <span class="n">Intersect</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">child1</span><span class="p">);</span>
  <span class="n">hit2</span> <span class="o">=</span> <span class="n">Intersect</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">child2</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">the</span> <span class="n">closer</span> <span class="n">of</span> <span class="n">hit1</span><span class="p">,</span> <span class="n">hit2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Spatial vs. Object Partitions</p>

<ul>
  <li>Spatial partition(e.g. KD-Tree)
    <ul>
      <li>Partition space into non-overlapping regions</li>
      <li>An object can be contained in multiple regions</li>
    </ul>
  </li>
  <li>Object partition(e.g. BVH)
    <ul>
      <li>Partition set of objects into disjoint subsets</li>
      <li>Bounding boxes for each set may overlap in space</li>
    </ul>
  </li>
</ul>

<h3 id="basic-radiometry">Basic Radiometry</h3>

<h4 id="motivation">Motivation</h4>

<p>之前提到的Blinn-Phong模型并没有给出I的物理意义，对于Whitted光线追踪来说，也是缺少一些变量的定义。</p>

<p>All the answers can be found in radiometry!</p>

<h4 id="radiometry">Radiometry</h4>

<ul>
  <li>Measurement system and unit for illumination</li>
  <li>Accurately measure the spatial properties of light
    <ul>
      <li>New terms: Radiant flux, intensity, irradiance, radiance</li>
    </ul>
  </li>
  <li>Perform lighting calculations <strong>in a physically correct manner</strong></li>
</ul>

<h4 id="radiant-energy-and-fluxpower">Radiant Energy and Flux(Power)</h4>

<p>Definition: Radiant energy is the energy of electromagnetic radiation. It is measured in units of joules, and denoted by the symbol:</p>

\[Q[\mathrm{J} = \mathrm{Joule}]\]

<p>Definition: Radiant flux(power) is the energy emitted, reflected, transmitted or received, per unit time.</p>

\[\Phi \equiv \frac{\mathrm{d}Q}{\mathrm{d}t}
  [\mathrm{W} = \mathrm{Watt}] [\mathrm{lm} = \mathrm{lumen}]\]

<p>Flux - # photons flowing through a sensor in unit time</p>

<h4 id="important-light-measurements-of-interest">Important Light Measurements of Interest</h4>

<ul>
  <li>Radiant Intensity - Light Emitted From A Source</li>
  <li>Irradiance - Light Falling On A Surface</li>
  <li>Radiance - Light Traveling Along A ray</li>
</ul>

<h4 id="radiant-intensity">Radiant Intensity</h4>

<p>Definition: The radiant(luminous) intensity is the power per unit <strong>solid angle</strong>（立体角） emitted by a point light source.</p>

\[I(\omega) \equiv \frac{\mathrm{d}\Phi}{\mathrm{d}\omega}\]

\[\left[\frac{\mathrm{W}}{\mathrm{sr}}\right]\left[\frac{\mathrm{lm}}{\mathrm{sr}} = \mathrm{cd} = \mathrm{candela}\right]\]

<p>Angles and Solid Angles</p>

<ul>
  <li>Angle: ratio of subtended arc length on circle to radius
    <ul>
      <li>$\theta = \frac{l}{r}$</li>
      <li>Circle has $2\pi$ radians</li>
    </ul>
  </li>
  <li>Solid angle: ratio of subtended area on sphere to radius squared
    <ul>
      <li>$\Omega = \frac{A}{r^2}$</li>
      <li>Sphere has $4\pi$ steradians</li>
    </ul>
  </li>
</ul>

<p>Differential Solid Angles</p>

\[\mathrm{d}A = (r\mathrm{d}\theta)(r\sin\theta\mathrm{d}\phi) = r^2\sin\theta\mathrm{d}\theta\mathrm{d}\phi\]

<p>单位立体角</p>

\[\mathrm{d}\omega = \frac{\mathrm{d}A}{r^2} = \sin\theta\mathrm{d}\theta\mathrm{d}\phi\]

<p>如果对一个球各个方向的单位立体角进行积分，</p>

\[\Omega = \int_{S^2}\mathrm{d}\omega = \int_{0}^{2\pi}\int_{0}^\pi
\sin\theta \mathrm{d}\theta\mathrm{d}\phi = 4\pi\]

<p>这同之前立体角的定义相符合；对于均匀照射的点光源，我们沿各个单位立体角对Radiant Intensity进行积分，可得</p>

\[\Phi = \int_{S^2}I\mathrm{d}\omega = 4\pi I\\\]

<p>因此对于均匀的点光源而言，</p>

\[I = \frac{\Phi}{4\pi}.\]

<h2 id="lecture-15-ray-tracing-3light-transport--global-illumination">Lecture 15 Ray Tracing 3(Light Transport &amp; Global Illumination)</h2>

<p>本讲内容</p>

<ul>
  <li>Radiometry cont.</li>
  <li>Light transport
    <ul>
      <li>The reflection equation</li>
      <li>The rendering equation</li>
    </ul>
  </li>
  <li>Global illumination</li>
  <li>Probability review</li>
</ul>

<h3 id="irradiance">Irradiance</h3>

<p>Definition: The irradiance is the power per(perpendicular/projected) unit area incident on a surface point.</p>

\[E(\mathbf{x}) \equiv \frac{\mathrm{d}\Phi(\mathbf{x})}{\mathrm{d}A}\]

\[\left[\frac{\mathrm{W}}{\mathrm{m}^2}\right]\left[\frac{\mathrm{lm}}{\mathrm{m}^2} = \mathrm{lux}\right]\]

<h4 id="lamberts-cosine-law">Lambert’s Cosine Law</h4>

<p>Irradiance at surface is proportional to cosine of angle between light direction and surface normal.</p>

<h4 id="correction-irradiance-falloff">Correction: Irradiance Falloff</h4>

<ul>
  <li>Assume light is emitting power $\Phi$ in a uniform angular distribution</li>
  <li>计算从光源出发，沿$\Phi$方向在两个不同距离的球面上的Radiant Intensity，由于其只与单位立体角有关，而其始终是$\Phi$，因此两处的Radiant Intensity是相同的；而由于Irradiance计算的是单位面积上的能量，因此Irradiance会随着距离的增加按距离的平方反比逐渐衰减。</li>
</ul>

<h3 id="radiance">Radiance</h3>

<p>Radiance is the fundamental field quantity that describes the distribution of light in an environment</p>

<ul>
  <li>Radiance is the quantity associated with a ray</li>
  <li>Rendering is all about computing radiance</li>
</ul>

<p>Definition: The radiance(luminance) is the power emitted, reflected, transmitted or received by a surface, <strong>per unit solid angle</strong>, <em>per projected unit area</em>.</p>

\[L(p, \omega) \equiv \frac{\mathrm{d}^2\Phi(p, \omega)}{\mathrm{d}\omega\mathrm{d}A\cos\theta},\]

<p>where $\cos \theta$ accounts for projected surface area.</p>

\[\left[\frac{\mathrm{W}}{\mathrm{sr}\ \mathrm{m}^2}\right]\left[\frac{\mathrm{cd}}{\mathrm{m}^2} =\frac{\mathrm{lm}}{\mathrm{sr\ m}^2} = \mathrm{nit}\right]\]

<p>Recall</p>

<ul>
  <li>Irradiance: power per projected unit area</li>
  <li>Intensity：power per solid angle</li>
</ul>

<p>So</p>

<ul>
  <li>Radiance: Irradiance per solid angle</li>
  <li>Radiance: Intensity per projected unit area</li>
</ul>

<p>所以可以进一步得到如下新的定义：</p>

<p>Incident Radiance</p>

<ul>
  <li>Incident radiance is the irradiance per unit solid angle arriving at the surface.</li>
  <li>i.e., it is the light arriving at the surface along a given ray(point on surface and incident direction)</li>
</ul>

\[L(p, \omega) = \frac{\mathrm{d}E(p)}{\mathrm{d}\omega \cos \theta}\]

<p>Exiting Radiance</p>

<ul>
  <li>Exiting radiance is the intensity per unit projected area leaving the surface.</li>
  <li>e.g., for an area light it is the light emitted along a given ray(point on surface and exit direction).</li>
</ul>

\[L(p, \omega) = \frac{\mathrm{d}I(p, \omega)}{\mathrm{d}A \cos \theta}\]

<p>这里之所以用的分别是Irradiance和Intensity进行微分，是因为对于一个反射问题，我们需要考虑的两件事分别是</p>

<ul>
  <li>给定方向的光照打在单位面上吸收多少能量</li>
  <li>从单位面发出的光照会打到任意方向，落在特定方向上的能量是多少</li>
</ul>

<p>这两件事就决定了对于Incident Radiance和Exiting Radiance，分别采取不同的格式来定义。</p>

<p>Irradiance vs. Radiance</p>

<ul>
  <li>Irradiance: total power received by area $\mathrm{d} A$</li>
  <li>Radiance: power received by area $\mathrm{d} A$ from “direction” $\mathrm{d}\omega$</li>
</ul>

\[\mathrm{d}E(p, \omega) = L_i(p, \omega) \cos \theta \mathrm{d}\omega\]

\[E(p) = \int_{H^2}L_i(p, omega)\cos\theta\mathrm{d}\omega\]

<p>差别就是一个方向性。</p>

<h4 id="brdf-bidirectional-reflectance-distribution-function-双向反射分布函数">BRDF: Bidirectional Reflectance Distribution Function 双向反射分布函数</h4>

<p>用来说明如果一个能量，从某个方向进来，将会沿指定方向分布多少能量。</p>

<p>Reflection at a Point</p>

<ul>
  <li>Radiance from direction $\omega_i$ turns into the power $E$ that $\mathrm{d}A$ receives</li>
  <li>Then the power $E$ will become the radiance to any other direction $\omega_o$</li>
</ul>

<p>BRDF</p>

<ul>
  <li>The Bidirectional Reflectance Distribution Function(BRDF) represents how much light is reflected into each outgoing direction $\omega_r$ from each incoming direction</li>
</ul>

\[f_r(\omega_i\rightarrow \omega_r) = \frac{\mathrm{d}L_r(\omega)}{\mathrm{d}E_i(\omega_i)} = \frac{\mathrm{d}L_r(\omega_r)}{L_i(\omega_i)\cos\theta_i\mathrm{d}\omega_i}\quad \left[\frac{1}{\mathrm{sr}}\right]\]

<p>描述了光线和物体是如何作用的，因此$f$定义了不同的材质</p>

<p>The Reflection Equation</p>

\[L_r(p, \omega_r) = \int_{H^2}f_r(p, \omega\rightarrow \omega_r)L_i(p, \omega_i)\cos\theta_i \mathrm{d}\omega_i\]

<h4 id="the-rendering-equation">The Rendering Equation</h4>

<ul>
  <li>Re-write the reflection equation by adding an Emission term to make it general:</li>
</ul>

\[L_o(p, \omega_o) = L_e(p, \omega_o) + \int_{\Omega^+}L_i(p, \omega_i)f_r(p, \omega_i, \omega_o) (n \cdot \omega_i) \mathrm{d}\omega_i\]

<p>Note: now, we assume that all directions are pointing outwards.</p>

<p>对于渲染方程，如果我们仅考虑一次反射，则$L_i$与$L_o$并无关联。但是当我们递归考虑，即经过光源照射后的每个面都会照射其他面，则此时的渲染方程可以写作</p>

\[L_r(x, \omega_r) = L_e(p, \omega_r) + \int_{\Omega}L_r(x', -\omega_i)f_r(x, \omega_i, \omega_r) \cos\theta_i \mathrm{d}\omega_i\]

<p>此时在渲染方程的结构中未知项仅为$L_r$，发现其实际上是一个第二类Fredholm Integral Equation，其一般形式为</p>

\[l(u) = e(u) + \int l(v) K(u, v)\mathrm{d}v\]

<p>如果进一步用算子$L, E, K$来替代上述表示，则有</p>

\[L = E + KL,\]

<p>which can be discretized to a simple matrix equation($L, E$ are vectors, $K$ is the light transport matrix)</p>

<ul>
  <li>General class numerical Monte Carlo methods</li>
  <li>Approximate set of all paths of light in scene</li>
</ul>

\[L = E + KL \Rightarrow (I-K)L = E \\ \Rightarrow L = (I-K)^{-1}E = E + KE + K^2E + \cdots\]

<p>由此得到的便是全局光照结果，具体来说，$E$是光源项，$KE$是直接光照项（一次反射，能够体现阴影），$K^2E$及以后是间接光照项（镜子和其他非光源的反射）。对于光栅化这种方法，对于光源和直接光照会有很好的刻画，对于间接光照部分比较难处理。</p>

<h3 id="probability-review">Probability Review</h3>

<ul>
  <li>$X$: random variable. Represents a distribution of potential values</li>
  <li>$X\sim p(x)$: probability density function(PDF). Describes relative probability of a random process choosing value $x$</li>
  <li>$E[x]$: Expected Value of a Random Variable. The average value that one obtains if repeatedly drawing samples from the random distribution.</li>
</ul>

\[E[X] = \int xp(x)\mathrm{d}x \\
  E[f(X)] = \int f(x)p(x)\mathrm{d}x\]

<h2 id="lecture-16-ray-tracing-4monte-carlo-path-tracing">Lecture 16 Ray-Tracing 4(Monte Carlo Path Tracing)</h2>

<p>本讲内容</p>

<ul>
  <li>A Brief Review</li>
  <li>Monte Carlo Integration</li>
  <li>Path Tracing</li>
</ul>

<h3 id="review">Review</h3>

<h4 id="review---the-rendering-equation">Review - The Rendering Equation</h4>

<p>Describing the light transport</p>

\[L_o(p, \omega_o) = L_e(p, \omega_o) + \int_{\Omega^+}L_i(p, \omega_i)f_r(p, \omega_i, \omega_o) (n \cdot \omega_i) \mathrm{d}\omega_i\]

<h4 id="review---probabilities">Review - Probabilities</h4>

<ul>
  <li>Continuous Variable and Probability Density Functions</li>
  <li>Understanding: randomly pick an $X$ –&gt; more likely to be a number closer to 0(in this case)</li>
</ul>

<h3 id="monte-carlo-integration">Monte Carlo Integration</h3>

<ul>
  <li>Why: we want to solve an integral, but it can be too difficult to solve analytically.</li>
  <li>What &amp; How: estimate the integral of a function by averaging random samples of the function’s value.</li>
</ul>

<p>Let us define the Monte Carlo estimator for the definite integral of given function $f(x)$</p>

<ul>
  <li>Definite integral: $\int_a^b f(x)\mathrm{d}x$</li>
  <li>Random variable: $X_i \sim p(x)$</li>
  <li>Monte Carlo estimator: $F_N = \frac{1}{N}\sum_{i = 1}^N\frac{f(X_i)}{p(X_i)}$</li>
</ul>

<blockquote>
  <p>$p$提供了采样${X_i}$的规则，对于概率密度大的位置，可以采样的次数也会变多，因此分母需要除以$p(X_i)$</p>
</blockquote>

<p>Some notes</p>

<ul>
  <li>The more samples, the less variance.</li>
  <li>Sample on x, integrate on x.</li>
</ul>

<h3 id="path-tracing">Path Tracing</h3>

<p>Motivation: Whitted-Style Ray Tracing:</p>

<ul>
  <li>Always perform specular reflections/refractions</li>
  <li>Stop bouncing at diffuse surfaces</li>
</ul>

<p>which are not absolutely right. Whitted-style ray tracing is wrong. But the rendering equation is correct. But it involves</p>

<ul>
  <li>Solving an integral over the hemisphere, and</li>
  <li>Recursive execution</li>
</ul>

<h4 id="a-simple-monte-carlo-solutiondirect-illumination">A Simple Monte Carlo Solution(Direct Illumination)</h4>

<p>We want to compute the radiance at $p$ towards the camera</p>

\[L_o(p, \omega_o) = \int_{\Omega^+}L_i(p, \omega_i)f_r(p, \omega_i, \omega_o) (n \cdot \omega_i) \mathrm{d}\omega_i\]

<p>Monte Carlo integration:</p>

\[\int_a^b f(x)\mathrm{d}x \approx \frac{1}{N}\sum_{i = 1}^N\frac{f(X_i)}{p(X_k)},\qquad X_i \sim p(x)\]

<p>What’s our “$f(x)$”?</p>

\[L_i(p, \omega_i)f_r(p, \omega_i, \omega_o) (n \cdot \omega_i)\]

<p>What’s our pdf?</p>

\[p(\omega_i) = \frac{1}{2\pi}\]

<p>(assume uniformly sampling the hemisphere)</p>

<p>So, in general</p>

\[L_o(p, \omega_o) = \int_{\Omega^+}L_i(p, \omega_i)f_r(p, \omega_i, \omega_o) (n \cdot \omega_i) \mathrm{d}\omega_i\\
  \approx \frac{1}{N}\sum_{i = 1}^N\frac{  L_i(p, \omega_i)f_r(p, \omega_i, \omega_o) (n \cdot \omega_i)}{p(\omega_i)}\]

<p>What does it mean? A correct shading algorithm for direct illumination!</p>

<p>Algorithm:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shade</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
  <span class="n">Randomly</span> <span class="n">choose</span> <span class="n">N</span> <span class="n">directions</span> <span class="n">wi</span><span class="o">~</span><span class="n">pdf</span>
  <span class="n">Lo</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="n">For</span> <span class="n">each</span> <span class="n">wi</span>
    <span class="n">Trace</span> <span class="n">a</span> <span class="n">ray</span> <span class="n">r</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wi</span><span class="p">)</span>
    <span class="n">If</span> <span class="n">ray</span> <span class="n">r</span> <span class="n">hit</span> <span class="n">the</span> <span class="n">light</span>
      <span class="n">Lo</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">L_i</span> <span class="o">*</span> <span class="n">f_r</span> <span class="o">*</span> <span class="n">cosine</span> <span class="o">/</span> <span class="n">pdf</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span>
  <span class="n">Return</span> <span class="n">Lo</span>
</code></pre></div></div>

<h4 id="introducing-global-illumination">Introducing Global Illumination</h4>

<p>One more step forward: what if a ray hits an object?</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shade</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
  <span class="n">Randomly</span> <span class="n">choose</span> <span class="n">N</span> <span class="n">directions</span> <span class="n">wi</span><span class="o">~</span><span class="n">pdf</span>
  <span class="n">Lo</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="n">For</span> <span class="n">each</span> <span class="n">wi</span>
    <span class="n">Trace</span> <span class="n">a</span> <span class="n">ray</span> <span class="n">r</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wi</span><span class="p">)</span>
    <span class="n">If</span> <span class="n">ray</span> <span class="n">r</span> <span class="n">hit</span> <span class="n">the</span> <span class="n">light</span>
      <span class="n">Lo</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">L_i</span> <span class="o">*</span> <span class="n">f_r</span> <span class="o">*</span> <span class="n">cosine</span> <span class="o">/</span> <span class="n">pdf</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span>
    <span class="n">Else</span> <span class="n">If</span> <span class="n">ray</span> <span class="n">r</span> <span class="n">hit</span> <span class="n">an</span> <span class="n">object</span> <span class="n">at</span> <span class="n">q</span>
      <span class="n">Lo</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">shade</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">-</span><span class="n">wi</span><span class="p">)</span> <span class="o">*</span> <span class="n">f_r</span> <span class="o">*</span> <span class="n">cosine</span> <span class="o">/</span> <span class="n">pdf</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span>
  <span class="n">Return</span> <span class="n">Lo</span>
</code></pre></div></div>

<h4 id="problem-1-explosion-of-rays-as-bounces-go-up">Problem 1: Explosion of #rays as #bounces go up</h4>

<p>From now on, we always assume that one <strong>1 ray</strong> is traced at each shading point:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shade</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
  <span class="n">Randomly</span> <span class="n">choose</span> <span class="n">ONE</span> <span class="n">directions</span> <span class="n">wi</span><span class="o">~</span><span class="n">pdf</span>
  <span class="n">Lo</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="n">For</span> <span class="n">each</span> <span class="n">wi</span>
    <span class="n">Trace</span> <span class="n">a</span> <span class="n">ray</span> <span class="n">r</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wi</span><span class="p">)</span>
    <span class="n">If</span> <span class="n">ray</span> <span class="n">r</span> <span class="n">hit</span> <span class="n">the</span> <span class="n">light</span>
      <span class="n">Lo</span> <span class="o">+=</span> <span class="n">L_i</span> <span class="o">*</span> <span class="n">f_r</span> <span class="o">*</span> <span class="n">cosine</span> <span class="o">/</span> <span class="n">pdf</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span>
    <span class="n">Else</span> <span class="n">If</span> <span class="n">ray</span> <span class="n">r</span> <span class="n">hit</span> <span class="n">an</span> <span class="n">object</span> <span class="n">at</span> <span class="n">q</span>
      <span class="n">Lo</span> <span class="o">+=</span> <span class="n">shade</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">-</span><span class="n">wi</span><span class="p">)</span> <span class="o">*</span> <span class="n">f_r</span> <span class="o">*</span> <span class="n">cosine</span> <span class="o">/</span> <span class="n">pdf</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span>
  <span class="n">Return</span> <span class="n">Lo</span>
</code></pre></div></div>

<p>This is <strong>path tracing</strong>(Distributed Ray Tracing if $N != 1$)</p>

<p>But this will be noisy!</p>

<ul>
  <li>No problem, just trace more paths through each pixel and average their radiance!</li>
</ul>

<p>Ray Generation</p>

<p>Very similar to ray casting in ray tracing</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ray_generation</span><span class="p">(</span><span class="n">camPos</span><span class="p">,</span> <span class="n">pixel</span><span class="p">)</span>
  <span class="n">Uniformly</span> <span class="n">choose</span> <span class="n">N</span> <span class="n">sample</span> <span class="n">positions</span> <span class="n">within</span> <span class="n">the</span> <span class="n">pixel</span>
  <span class="n">pixel_radiance</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="n">For</span> <span class="n">each</span> <span class="n">sample</span> <span class="n">in</span> <span class="n">the</span> <span class="n">pixel</span>
    <span class="n">Shoot</span> <span class="n">a</span> <span class="n">ray</span> <span class="n">r</span><span class="p">(</span><span class="n">camPos</span><span class="p">,</span> <span class="n">cam_to_sample</span><span class="p">)</span>
    <span class="n">If</span> <span class="n">ray</span> <span class="n">r</span> <span class="n">hit</span> <span class="n">the</span> <span class="n">scene</span> <span class="n">at</span> <span class="n">p</span>
      <span class="n">pixel_radiance</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">N</span> <span class="o">*</span> <span class="n">shade</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sample_to_cam</span><span class="p">)</span>
  <span class="n">Return</span> <span class="n">pixel_radiance</span>
</code></pre></div></div>

<h4 id="problem-2-the-recursive-algorithm-will-never-stop">Problem 2: The recursive algorithm will never stop</h4>

<p>Solution: Russian Roulette(RR)</p>

<ul>
  <li>Russian Roulette is all about probability
    <ul>
      <li>With probability $0 &lt; P &lt; 1$, you will fine</li>
      <li>With probability $1 - P$, otherwise</li>
    </ul>
  </li>
  <li>How to do
    <ul>
      <li>Previously, we always shoot a ray at a shading point and get the shading result $Lo$</li>
      <li>Suppose we manually set a probability $P(0 &lt; P &lt; 1)$</li>
      <li>With probability $P$, shoot a ray and return the shading result divided by $P$: $Lo / P$</li>
      <li>With probability $1-P$, don’t shoot a ray and you’ll get $0$</li>
    </ul>
  </li>
</ul>

<p>In this way, you can still <strong>expect</strong> to get $Lo$:</p>

\[E = P * (Lo / P) + (1 - P) * 0 = Lo\]

<p>Modified Algorithm</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shade</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
  <span class="n">Manually</span> <span class="n">specify</span> <span class="n">a</span> <span class="n">probability</span> <span class="n">P_RR</span>
  <span class="n">Randomly</span> <span class="n">select</span> <span class="n">ksi</span> <span class="n">in</span> <span class="n">a</span> <span class="n">uniform</span> <span class="n">dist</span><span class="p">.</span> <span class="n">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">If</span><span class="p">(</span><span class="n">ksi</span> <span class="o">&gt;</span> <span class="n">P_RR</span><span class="p">)</span> <span class="k">return</span> <span class="mf">0.0</span><span class="p">;</span>

  <span class="n">Randomly</span> <span class="n">choose</span> <span class="n">ONE</span> <span class="n">directions</span> <span class="n">wi</span><span class="o">~</span><span class="n">pdf</span>
  <span class="n">Lo</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="n">For</span> <span class="n">each</span> <span class="n">wi</span>
    <span class="n">Trace</span> <span class="n">a</span> <span class="n">ray</span> <span class="n">r</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wi</span><span class="p">)</span>
    <span class="n">If</span> <span class="n">ray</span> <span class="n">r</span> <span class="n">hit</span> <span class="n">the</span> <span class="n">light</span>
      <span class="n">Lo</span> <span class="o">+=</span> <span class="n">L_i</span> <span class="o">*</span> <span class="n">f_r</span> <span class="o">*</span> <span class="n">cosine</span> <span class="o">/</span> <span class="n">pdf</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span> <span class="o">/</span> <span class="n">P_RR</span>
    <span class="n">Else</span> <span class="n">If</span> <span class="n">ray</span> <span class="n">r</span> <span class="n">hit</span> <span class="n">an</span> <span class="n">object</span> <span class="n">at</span> <span class="n">q</span>
      <span class="n">Lo</span> <span class="o">+=</span> <span class="n">shade</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">-</span><span class="n">wi</span><span class="p">)</span> <span class="o">*</span> <span class="n">f_r</span> <span class="o">*</span> <span class="n">cosine</span> <span class="o">/</span> <span class="n">pdf</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span> <span class="o">/</span> <span class="n">P_RR</span>
  <span class="n">Return</span> <span class="n">Lo</span>
</code></pre></div></div>

<h4 id="sampling-the-lightpure-math">Sampling the light(pure math)</h4>

<p>Now we already have a correct version of path tracing! But it’s not really efficient.</p>

<p>The reason of being inefficient: A lot of rays are “wasted” if we uniformly sample the hemisphere at the shading point.</p>

<p>Monte Carlo methods allows any sampling methods, so we can sample the light(therefore no rays are “wasted”)</p>

<ul>
  <li>Assume uniformly sampling on the light:
    <ul>
      <li>$pdf = 1 / A$(because $\int pdf \mathrm{d}A = 1$)</li>
      <li>But the rendering equation integrates on the solid angle: $Lo = \int Li fr \cos \mathrm{d}\omega$</li>
    </ul>
  </li>
  <li>Recall Monte Carlo Integration: Sample on $x$ &amp; integrate on $x$
    <ul>
      <li>Can we sample on the light, can we integrate on the light?</li>
    </ul>
  </li>
  <li>Need to make the rendering equation as an integral of $\mathrm{d}A$
    <ul>
      <li>Need the relationship between $\mathrm{d}\omega$ and $\mathrm{d}A$</li>
      <li>Recall the alternative def. of solid angle: Projected area on the unit sphere</li>
      <li>$\mathrm{d}\omega = \frac{\mathrm{d}A\cos\theta’}{|x’ - x|^2}$</li>
    </ul>
  </li>
  <li>Then we can rewrite teh rendering equation as</li>
</ul>

\[L_o(p, \omega_o) = \int_{\Omega^+}L_i(p, \omega_i)f_r(p, \omega_i, \omega_o) \cos \theta \mathrm{d}\omega_i \\
  = \int_A L_i(p, \omega_i)f_r(p, \omega_i, \omega_o) \frac{\cos\theta\cos\theta'}{\|x' - x\|^2} \mathrm{d}A\]

<p>Now the modified Monte Carlo integration:</p>

<ul>
  <li>“$f(x)$”: everything inside</li>
  <li>pdf: $1 / A$</li>
</ul>

<p>Now we consider the radiance coming from two parts:</p>

<ol>
  <li>light source(direct, no need to have RR)</li>
  <li>other reflectors(indirect, RR)</li>
</ol>

<p>Modified Algorithm:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shade</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wo</span><span class="p">)</span>
  <span class="c1">// Contribution from the light source.</span>

  <span class="n">Uniformly</span> <span class="n">sample</span> <span class="n">the</span> <span class="n">light</span> <span class="n">at</span> <span class="n">x</span><span class="err">'</span> <span class="p">(</span><span class="n">pdf_light</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">A</span><span class="p">)</span>
  <span class="n">L_dir</span> <span class="o">=</span> <span class="n">L_i</span> <span class="o">*</span> <span class="n">f_r</span> <span class="o">*</span> <span class="n">cos</span> <span class="n">theta</span> <span class="o">*</span> <span class="n">cos</span> <span class="n">theta</span><span class="err">'</span> <span class="o">/</span> <span class="o">|</span><span class="n">x</span><span class="err">'</span> <span class="o">-</span> <span class="n">p</span><span class="o">|^</span><span class="mi">2</span> <span class="o">/</span> <span class="n">pdf_light</span>

  <span class="c1">// Contribution from other reflectors.</span>

  <span class="n">L_indir</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="n">Test</span> <span class="n">Russian</span> <span class="n">Roulette</span> <span class="n">with</span> <span class="n">probability</span> <span class="n">P_RR</span>
  <span class="n">Uniformly</span> <span class="n">sample</span> <span class="n">the</span> <span class="n">hemisphere</span> <span class="n">toward</span> <span class="n">wi</span><span class="p">(</span><span class="n">pdf_hemi</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="n">pi</span><span class="p">)</span>
  <span class="n">Trace</span> <span class="n">a</span> <span class="n">ray</span> <span class="n">r</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wi</span><span class="p">)</span>
  <span class="n">If</span> <span class="n">ray</span> <span class="n">r</span> <span class="n">hit</span> <span class="n">a</span> <span class="n">non</span><span class="o">-</span><span class="n">emitting</span> <span class="n">object</span> <span class="n">at</span> <span class="n">q</span>
    <span class="n">L_indir</span> <span class="o">=</span> <span class="n">shade</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">-</span><span class="n">wi</span><span class="p">)</span> <span class="o">*</span> <span class="n">f_r</span> <span class="o">*</span> <span class="n">cos</span> <span class="n">theta</span> <span class="o">/</span> <span class="n">pdf_hemi</span> <span class="o">/</span> <span class="n">P_RR</span>

  <span class="n">Return</span> <span class="n">L_dir</span> <span class="o">+</span> <span class="n">L_indir</span>
</code></pre></div></div>

<p>One final thing: how do we know if the sample on teh light is not blocked or not?</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">L_dir</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="n">Uniformly</span> <span class="n">sample</span> <span class="n">the</span> <span class="n">light</span> <span class="n">at</span> <span class="n">x</span><span class="err">'</span> <span class="p">(</span><span class="n">pdf_light</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">A</span><span class="p">)</span>
  <span class="n">Shoot</span> <span class="n">a</span> <span class="n">ray</span> <span class="n">from</span> <span class="n">p</span> <span class="n">to</span> <span class="n">x</span><span class="err">'</span>
  <span class="n">If</span> <span class="n">the</span> <span class="n">ray</span> <span class="n">is</span> <span class="n">not</span> <span class="n">blocked</span> <span class="n">in</span> <span class="n">the</span> <span class="n">middle</span>
    <span class="n">L_dir</span> <span class="o">=</span> <span class="p">...</span>
</code></pre></div></div>

<h4 id="is-path-tracing-correct">Is Path Tracing Correct?</h4>

<p><strong>Yes, almost 100% correct, a.k.a PHOTO-REALISTIC.</strong></p>

<h4 id="is-path-tracing-introductory">Is Path Tracing “Introductory”?</h4>

<p><strong>This time, yes. Fear the science, my friends.</strong></p>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="Learning Notes" /><category term="GAMES101" /><summary type="html"><![CDATA[GAMES101: 现代计算机图形学入门 笔记04：Ray-Tracing]]></summary></entry><entry><title type="html">GAMES101_notes_03</title><link href="http://localhost:4000/2023/02/04/GAMES101_notes_03/" rel="alternate" type="text/html" title="GAMES101_notes_03" /><published>2023-02-04T23:23:00+08:00</published><updated>2023-02-04T23:23:00+08:00</updated><id>http://localhost:4000/2023/02/04/GAMES101_notes_03</id><content type="html" xml:base="http://localhost:4000/2023/02/04/GAMES101_notes_03/"><![CDATA[<blockquote>
  <p>GAMES101: 现代计算机图形学入门</p>

  <p>笔记03：Geometry</p>
</blockquote>

<h2 id="lesson-10-geometry-1introduction">Lesson 10 Geometry 1(Introduction)</h2>

<p>本讲内容</p>

<ul>
  <li>Shading 3
    <ul>
      <li>Applications of textures(写在第九讲笔记最后)</li>
    </ul>
  </li>
  <li>Introduction to geometry
    <ul>
      <li>Examples of geometry</li>
      <li>Various representations of geometry</li>
    </ul>
  </li>
</ul>

<h3 id="introduction-to-geometry">Introduction to geometry</h3>

<h4 id="many-ways-to-represent-geometry">Many Ways to Represent Geometry</h4>

<p>几何的显式表示和隐式表示</p>

<ul>
  <li>Implicit
    <ul>
      <li>algebraic surface</li>
      <li>level sets</li>
      <li>distance functions</li>
      <li>…</li>
    </ul>
  </li>
  <li>Explicit
    <ul>
      <li>point cloud</li>
      <li>polygon mesh</li>
      <li>subdivision, NURBS</li>
      <li>…</li>
    </ul>
  </li>
</ul>

<p>Each choice best suited to a different task/type of geometry</p>

<p>“Implicit” Representations of Geometry</p>

<ul>
  <li>Based on classifying points
    <ul>
      <li>Point satisfy some specified relationship</li>
    </ul>
  </li>
  <li>Sampling can be hard</li>
  <li>Inside/Outside tests is easy</li>
</ul>

<p>“Explicit” Representations of Geometry</p>

<ul>
  <li>All points are <strong>given directly</strong> or <strong>via parameter mapping</strong></li>
  <li>Sampling is easy</li>
  <li>Inside/Outside Test Hard</li>
</ul>

<p>Conclusion: <strong>Bset representation depends on the task.</strong></p>

<p>More Implicit representations in Computer Graphics</p>

<ul>
  <li>Algebraic Surfaces
    <ul>
      <li>非常不直观，且无法处理复杂几何结构</li>
    </ul>
  </li>
  <li>Constructive Solid Geometry(CSG)
    <ul>
      <li>通过对简单几何体进行布尔运算</li>
      <li>可以得到复杂几何结构的表示</li>
    </ul>
  </li>
  <li>Distance Functions
    <ul>
      <li>Instead of Booleans, gradually blend surfaces together using Distance functions:</li>
      <li>Giving minimum distance(could be signed distance) from anywhere to object</li>
    </ul>
  </li>
  <li>Level Set Method
    <ul>
      <li>Closed-form equation are hard to describe complex shapes</li>
      <li>Alternative: store a grid of values approximating function</li>
      <li>Surface is found where interpolated values equal zero</li>
      <li>Provides such more explicit control over shape(like a texture)</li>
    </ul>
  </li>
  <li>Fractals 分形
    <ul>
      <li>Exhibit self-similarity, detail at all scales</li>
      <li>“Language” for describing natural phenomena</li>
      <li>Hard to control shape</li>
    </ul>
  </li>
</ul>

<h4 id="implicit-representations---pros--cons">Implicit Representations - Pros &amp; Cons</h4>

<ul>
  <li>Pros:
    <ul>
      <li>compact description(e.g., a function)</li>
      <li>certain queries easy(inside object, distance to surface)</li>
      <li>good for ray-to-surface intersection(more later)</li>
      <li>for simple shapes, exact description / no sampling error</li>
      <li>easy to handle changes in topology(e.g., fluid)</li>
    </ul>
  </li>
  <li>Cons:
    <ul>
      <li>difficult ot model complex shapes</li>
    </ul>
  </li>
</ul>

<h4 id="explicit-representations-in-computer-graphicslater">Explicit Representations in Computer Graphics(later)</h4>

<h2 id="lesson-11-geometry-2curves-and-surfaces">Lesson 11 Geometry 2(Curves and Surfaces)</h2>

<p>本讲内容：</p>

<ul>
  <li>Explicit Representations</li>
  <li>Curves
    <ul>
      <li>Bezier curves</li>
      <li>De Casteljau’s Algorithm</li>
      <li>B-splines, etc.</li>
    </ul>
  </li>
  <li>Surfaces
    <ul>
      <li>Bezier surfaces</li>
      <li>Triangles &amp; quads
        <ul>
          <li>Subdivision, simplification, regularization</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="explicit-representations-in-computer-graphics">Explicit Representations in Computer Graphics</h3>

<p>Many Explicit Representations in Graphics</p>

<ul>
  <li>triangle meshes</li>
  <li>Bezier surfaces</li>
  <li>subdivision surfaces</li>
  <li>NURBS</li>
  <li>point cloud</li>
  <li>…</li>
</ul>

<h4 id="point-cloud">Point Cloud</h4>

<ul>
  <li>Easiest representation: list of points $(x, y, z)$</li>
  <li>Easily represent any kind any kind of geometry</li>
  <li>Useful for LARGE datasets(»1 point/pixel)</li>
  <li>Often converted into polygon mesh</li>
  <li>Difficult to draw in undersampled regions</li>
</ul>

<h4 id="polygon-mesh">Polygon Mesh</h4>

<ul>
  <li>Store vertices &amp; polygons(often triangles or quads)</li>
  <li>Easier to do processing/simulation, adaptive sampling</li>
  <li>More complicated data structures</li>
  <li>Perhaps most common representation in graphics</li>
</ul>

<h4 id="the-wavefront-object-fileobj-format">The wavefront Object File(.obj) Format</h4>

<p>常用的文件存储格式（obj文件）</p>

<ul>
  <li>Commonly used in Graphics research</li>
  <li>Just a text file that specifies vertices, normals, texture coordinates and <strong>their connectivities</strong></li>
</ul>

<h3 id="curves">Curves</h3>

<h4 id="bezier-curve">Bezier Curve</h4>

<p>Defining Cubic Bezier Curve With Tangents</p>

<ul>
  <li>由四个点$p_0, p_1, p_2, p_3$定义的Bezier曲线，满足曲线的起始点为$p_0$，终点为$p_3$，且$p_0$处切线为$\overline{p_0, p_1}$，$p_3$处切线为$\overline{p_2, p_3}$。</li>
</ul>

<p>Evaluating Bezier Curves(de Casteljau Algorithm)</p>

<ul>
  <li>并不是直接得到曲线的表示，而是当假设初始点对应时刻0，结束点对应时刻1，则对于任意时刻$t\in [0, 1]$都可以直接求出该时刻的曲线对应位置（利用插值）。</li>
</ul>

<p>Evaluating Bezier Curves Algebraic Formula</p>

<ul>
  <li>de Casteljau algorithm gives a pyramid of coefficients</li>
  <li>Bernstein form of a Bezier curve of order n:</li>
</ul>

\[\mathbf{b}^n(t) = \mathbf{b}_0^n(t) = \sum_{j = 0}^n\mathbf{b}_jB_j^n(t),\]

<p>where Bernstein polynomial is</p>

\[B_i^n(t) = \begin{pmatrix}
        n \\
        i
    \end{pmatrix}
    t^i(1-t)^{n-i}\]

<p>Properties of Bezier Curves:</p>

<ul>
  <li>Interpolates endpoints
    <ul>
      <li>For cubic Bezier: $\mathbf{b}(0) = \mathbf{b}_0; \mathbf{b}(1) = \mathbf{b}_3$</li>
    </ul>
  </li>
  <li>Tangent to end segment
    <ul>
      <li>Cubic case: $\mathbf{b}’(0) = 3(\mathbf{b}_1 - \mathbf{b}_0); \mathbf{b}’(1) = 3(\mathbf{b}_3 - \mathbf{b}_2)$</li>
    </ul>
  </li>
  <li>Affine transformation property
    <ul>
      <li>Transform curve by transforming control points</li>
    </ul>
  </li>
  <li>Convex hull property
    <ul>
      <li>Curve is within convex hull of control points</li>
    </ul>
  </li>
</ul>

<p>Piecewise Bezier Curves</p>

<ul>
  <li>当控制点数量过多的时候，贝塞尔曲线不能很好刻画控制点的分布情况</li>
  <li>Therefore, <strong>piecewise cubic Bezier</strong> curve is the most common technique</li>
</ul>

<p>Piecewise Bezier Curve - Continuity</p>

<ul>
  <li>$C^0$ continuity</li>
  <li>$C^1$ continuity</li>
</ul>

<h4 id="other-types-of-splines">Other types of splines</h4>

<ul>
  <li>Spline
    <ul>
      <li>a continuous curve constructed so as to pass through a given set of points and have a certain number of continuous derivatives</li>
      <li>In short, a curve under control</li>
    </ul>
  </li>
  <li>B-Splines
    <ul>
      <li>Short for basis splines</li>
      <li>Require more information than Bezier curves</li>
      <li>Satisfy all important properties that Bezier curves have(i.e. superset)</li>
    </ul>
  </li>
</ul>

<h3 id="surfaces">Surfaces</h3>

<h4 id="bezier-surfaces">Bezier Surfaces</h4>

<p>Extend Bezier curves to surfaces</p>

<p>Evaluating Surface Position For Parameters $(u, v)$</p>

<ul>
  <li>For bi-cubic Bezier surface patch,
    <ul>
      <li>Input: $4\times 4$ control points</li>
      <li>Output: a 2D surface parameterized by $(u, v)$ in $[0, 1]^2$</li>
    </ul>
  </li>
</ul>

<p>Method: Separable 1D de Casteljau Algorithm</p>

<ul>
  <li>Use de Casteljau to evaluate point u on each of the 4 Bezier curves in $u$. This gives 4 control points for the “moving” Bezier curve</li>
  <li>Use 1D de Casteljau to evaluate point $v$ on the “moving” curve</li>
</ul>

<h4 id="subdivision-surfacestriangles--quads">Subdivision surfaces(triangles &amp; quads)</h4>

<p>Mesh Operations: Geometry Processing</p>

<ul>
  <li>Mesh subdivision 网格细分</li>
  <li>Mesh simplification 网格简化</li>
  <li>Mesh regularization 网格正规化</li>
</ul>

<h2 id="lecture-12-geometry-3">Lecture 12 Geometry 3</h2>

<h3 id="mesh-operations">Mesh Operations</h3>

<ul>
  <li>Mesh subdivision : Increase resolution</li>
  <li>Mesh simplification : Decrease resolution; try to preserve shape/appearance</li>
  <li>Mesh regularization : Modify sample distribution to improve quality</li>
</ul>

<h3 id="subdivision">Subdivision</h3>

<h4 id="loop-subdivision">Loop Subdivision</h4>

<ul>
  <li>Common subdivision rul for triangle meshes.</li>
</ul>

<p>First, create more triangles(vertices); Second, tune their positions</p>

<ul>
  <li>Split each triangle into four</li>
  <li>Assign new vertex positions according to weights
    <ul>
      <li>New/old vertices updated differently</li>
    </ul>
  </li>
</ul>

<p>更新规则</p>

<ul>
  <li>对于待更新的新顶点，利用共享其所在边的三角形上原顶点进行加权平均，得到新顶点的坐标</li>
  <li>对于待更新的原顶点，其结果为自身位置与相邻原顶点位置加权得到结果</li>
</ul>

<h4 id="catmull-clark-subdivisiongeneral-mesh">Catmull-Clark Subdivision(General Mesh)</h4>

<ul>
  <li>可以对非三角形网格进行细分</li>
</ul>

<p>定义四边形面为 quad face，其余面为 non-quad face，记度数不为4的顶点为extraordinary vertex(奇异点)</p>

<p>Each subdivision step:</p>

<ul>
  <li>Add vertex in each face</li>
  <li>Add midpoint on each edge</li>
  <li>Connect all new vertices</li>
</ul>

<p>After one subdivision:</p>

<ul>
  <li>How many extraordinary vertices? 原本的奇异点加上非四边形面中添加的点</li>
  <li>What are their degrees? 非四边形面的边数</li>
  <li>How many non-quad faces? 0</li>
</ul>

<p>相当于将非四边形面全部用奇异点替换了，再做细分的时候，非四边形面数量仍然是0，而且奇异点数量不会增加。</p>

<p>Catmull-Clark Vertex Updates Rules(Quad Mesh)</p>

<ul>
  <li>新增加的点，根据面中的点和边上的点，利用相邻的点进行加权平均；</li>
  <li>原有的点，利用周围新添加的点及其本身，进行加权平均。</li>
</ul>

<h3 id="mesh-simplification">Mesh Simplification</h3>

<p>Goal: reduce number of mesh elements while maintaining the overall shape</p>

<h4 id="collapsing-an-edge-边坍缩">Collapsing An Edge 边坍缩</h4>

<ul>
  <li>Suppose we simplify a mesh using edge collapsing</li>
</ul>

<p>Quadric Error Metrics 用来选择需要坍缩的边</p>

<ul>
  <li>How much geometric error is introduced by simplification?</li>
  <li>Not a good idea to perform local averaging of vertices</li>
  <li>Quadric error: New vertex should minimize its <strong>sum of square distance</strong>($L_2$ distance) to previous related triangle planes</li>
</ul>

<p>Quadric Error of Edge Collapse</p>

<ul>
  <li>How much does it cost to collapse an edge?</li>
  <li>Idea: Compute edge midpoint, measure quadric error</li>
</ul>

<p>Simplification via Quadric Error</p>

<ul>
  <li>Iteratively collapse edges</li>
  <li>Which edges? Assign score with quadric error metric
    <ul>
      <li>Approximate distance to surface as sum of distances to planes containing triangles</li>
      <li>Iteratively collapse edge <strong>with smallest score</strong></li>
      <li>Greedy algorithm… great results!</li>
    </ul>
  </li>
</ul>

<h3 id="shadows-mappingwith-rasterization">Shadows Mapping(with Rasterization)</h3>

<h4 id="shadow">Shadow</h4>

<ul>
  <li>How to draw shadows using rasterization?</li>
  <li><strong>Shadow mapping</strong>!</li>
</ul>

<h4 id="shadow-mapping只涉及点光源的硬阴影">Shadow Mapping（只涉及点光源的硬阴影）</h4>

<ul>
  <li>An Image-space Algorithm
    <ul>
      <li>no knowledge of scene’s geometry during shadow computation</li>
      <li>must deal with aliasing artifacts</li>
    </ul>
  </li>
  <li>Key idea:
    <ul>
      <li>thepoins NOT in shadow must be seen both <strong>by the light</strong> and <strong>by the camera</strong></li>
    </ul>
  </li>
</ul>

<p>具体实现方法：</p>

<ul>
  <li>Pass 1: Render from Light 记录光源按不同方向到场景得到的深度
    <ul>
      <li>Deep image from light source</li>
    </ul>
  </li>
  <li>Pass 2A: Render from Eye 确定从摄像机得到的场景中的具体像素
    <ul>
      <li>Standard image(with depth) from eye</li>
    </ul>
  </li>
  <li>Pass 2B: Project to light 从这些像素投影回光源，与之前对照的深度相比查看是否一致
    <ul>
      <li>Project visible points in eye view back to light source</li>
    </ul>
  </li>
</ul>

<p>Problems with shadow maps</p>

<ul>
  <li>Hard shadows(point lights only)</li>
  <li>Quality depends on shadow map resolution(general problem with image-based techniques)</li>
  <li>Involves equality comparison of floating point depth values means issues of scale, bias, tolerance</li>
</ul>

<p>Hard shadows vs. soft shadows</p>

<ul>
  <li>当阴影位置完全得不到光照，则该点处在本影区域，阴影是最硬的；否则阴影位置可以被部分光照，此时该点位于半影区域，阴影会比较软。</li>
</ul>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="Learning Notes" /><category term="GAMES101" /><summary type="html"><![CDATA[GAMES101: 现代计算机图形学入门 笔记03：Geometry]]></summary></entry><entry><title type="html">Solutions_to_GAMES101_Assignments</title><link href="http://localhost:4000/2023/01/31/Solutions_to_GAMES101_Assignments/" rel="alternate" type="text/html" title="Solutions_to_GAMES101_Assignments" /><published>2023-01-31T19:11:00+08:00</published><updated>2023-01-31T19:11:00+08:00</updated><id>http://localhost:4000/2023/01/31/Solutions_to_GAMES101_Assignments</id><content type="html" xml:base="http://localhost:4000/2023/01/31/Solutions_to_GAMES101_Assignments/"><![CDATA[<blockquote>
  <p>记录一下每个Assignment的设计思路，以及用到的知识</p>
</blockquote>

<h2 id="assignment-01-构建投影矩阵">Assignment 01 构建投影矩阵</h2>

<h3 id="任务要求">任务要求</h3>

<p>给定三维空间中的三个点$v_0(2.0, 0.0, -2.0), v_1(0.0, 2.0, -2.0), v_2(-2.0, 0.0, -2.0)$，由其组成三角形线框。</p>

<ul>
  <li>构建旋转矩阵，实现当输入”A”和”D”的时候，三角形将绕z轴旋转（Bonus: 将绕z轴旋转改为绕任意过原点的轴旋转）；</li>
  <li>构建透视投影矩阵。</li>
</ul>

<h3 id="知识点1旋转矩阵">知识点1：旋转矩阵</h3>

<p>完成这次作业首先需要考虑在齐次坐标的框架下如何构造旋转矩阵，以及如何构造透视投影矩阵。</p>

<p>对于第一个问题，构造旋转矩阵，在讲义中提到过，齐次坐标系中物体绕z轴旋转的矩阵形式如下：</p>

\[\mathbf{R}_z(\alpha)=
    \begin{pmatrix}\cos\alpha &amp; -\sin\alpha &amp; 0 &amp; 0 \\ \sin\alpha &amp; \cos\alpha &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}\]

<p>对附加问题，对任意过原点轴旋转，可以参见讲义中提到的Rodrigues旋转公式，绕过原点且方向为$\mathbf{n}$的轴，逆时针旋转$\alpha$的结果是</p>

\[\mathbf{R}(\mathbf{n}, \alpha) = \cos(\alpha) \mathbf{I} + (1-\cos(\alpha))\mathbf{n}\mathbf{n}^\mathrm{T} + \sin \alpha     \begin{pmatrix}0 &amp; -n_z &amp; n_y \\ n_z &amp; 0 &amp; -n_x \\  -n_y &amp; n_x &amp; 0\end{pmatrix}\]

<p>由于代码框架中的坐标系是齐次坐标系，因此还需要额外补充一个维度的结果。</p>

<h3 id="知识点2透视投影矩阵">知识点2：透视投影矩阵</h3>

<p>透视投影矩阵由两部分组成：</p>

\[\mathbf{M}_{persp}
 =
\mathbf{M}_{othro}
\mathbf{M}_{persp\rightarrow ortho}\]

<p>对于第一个部分，将透视投影变换为正交投影的矩阵，只需要按讲义中的方法处理即可：</p>

\[\mathbf{M}_{persp\rightarrow ortho}
 =
\begin{pmatrix}
n &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; n &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; n+f &amp; -nf\\
0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}\]

<p>对于正交矩阵，实际上就是将近视口的图像收缩到标准画框大小的缩放变换矩阵，注意代码框架中提供的接口参数并不是直接的视口长和宽，而是宽高比和垂直可视角度，使用时还需要进行一步转化。</p>

<h3 id="其他需要注意的地方">其他需要注意的地方</h3>

<p>由于课程提供的代码框架与课堂介绍的代码框架不完全相同，差别主要在于视口的位置是不一样的。在课上，老师介绍的摄像机朝向是z轴负方向，但是代码框架中给的是朝向z轴正方向，因此如果直接按讲义上的方法构造矩阵，结果将会是显示的图像为倒像。解决办法是将代码框架中的朝向改为z轴负方向。</p>

<h2 id="assignment-02-光栅化z-buffering">Assignment 02 光栅化+Z-buffering</h2>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="Learning Notes" /><category term="GAMES101" /><category term="Solution" /><summary type="html"><![CDATA[记录一下每个Assignment的设计思路，以及用到的知识]]></summary></entry><entry><title type="html">Computational_Geometry_notes_01</title><link href="http://localhost:4000/2023/01/14/Computational_Geometry_notes_01/" rel="alternate" type="text/html" title="Computational_Geometry_notes_01" /><published>2023-01-14T23:49:00+08:00</published><updated>2023-01-14T23:49:00+08:00</updated><id>http://localhost:4000/2023/01/14/Computational_Geometry_notes_01</id><content type="html" xml:base="http://localhost:4000/2023/01/14/Computational_Geometry_notes_01/"><![CDATA[<h2 id="chapter-09-delaunay-triangulations">Chapter 09 Delaunay Triangulations</h2>

<blockquote>
  <p>Used for height interpolation</p>
</blockquote>

<h3 id="introduction">Introduction</h3>

<p>(unfinished)</p>

<h3 id="triangulations-of-planar-point-sets">Triangulations of Planar Point Sets</h3>

<h4 id="the-definition-of-triangulation">The Definition of Triangulation</h4>

<p>令$P := {p_1, p_2, \dots, p_n}$为平面上的一组点集，我们首先定义 <em>最大平面子细分(maximal planar subdivision)</em>。</p>

<p>$P$的平面子细分$\mathcal{S}$是一个平面图，顶点为$P$的所有点，边为互不相交的线段，由于$P$包含的点是有限个，自然平面子细分的边数也存在上限。我们记包含最多边的细分为最大平面子细分$\mathcal{S_0}$，此时任意一条由$P$上两点连成，且不在$\mathcal{S_0}$中的线段都与$\mathcal{S_0}$中的某条线段相交。</p>

<p>由欧拉定律，$\mathcal{S_0}$的边数$n_e$取决于$P$中的点数$n$和$P$的凸包$\mathrm{CH}(P)$中包含的点数$k$，并满足如下关系式：</p>

\[n_e = 3n - 3 - k.\]

<p>在这样的定义下，我们还可以得知：$\mathcal{S_0}$构成的平面图中，最小单位的多边形结构都是三角形（否则，必然可以添加更多线段到$\mathcal{S_0}$中，矛盾！），因此，我们也称由$P$中点生成的最大平面子细分为$P$的 <em>三角剖分(triangulation)</em>，记作$\mathcal{T}$。</p>

<p>同样，$\mathcal{T}$中包含的三角形个数$n_t$也由$P$中的点数$n$和$P$的凸包$\mathrm{CH}(P)$中包含的点数$k$确定，并满足如下关系式：</p>

\[n_t = 2n - 2 - k.\]

<h4 id="angle-optimal-triangulation">Angle-optimal Triangulation</h4>

<p>在上述定义下，我们讨论$P$的三角剖分$\mathcal{T}$的性质，假设其中包含$m$个三角形。则$\mathcal{T}$中三角形的角共有$3m$个，将其按升序排列并编号，记为$\alpha_1, \alpha_2, \dots, \alpha_{3m}$，则它们满足对任意的$1\le i &lt; j \le 3m$都有$\alpha_i \le \alpha_j$。我们定义$A(\mathcal{T}) := (\alpha_1, \alpha_2, \dots, \alpha_{3m})$为$\mathcal{T}$的 <em>角度序列(angle-vector)</em>
。</p>

<p>令$\mathcal{T’}$为$P$的另一个三角剖分，它的角度序列$A(\mathcal{T’}) := (\alpha_1’, \alpha_2’, \dots, \alpha_{3m}’)$。如果存在$i$，$1\le i \le3m$，满足</p>

\[\alpha_j = \alpha'_j,\ \forall j &lt; i,\quad \alpha_i &lt; \alpha'_i.\]

<p>我们称角度序列$A(\mathcal{T})$比$A(\mathcal{T’})$大，记为$\mathcal{T} &gt; \mathcal{T’}$。</p>

<p>如果一个$P$的三角剖分$\mathcal{T_0}$满足对$P$的任意三角剖分$\mathcal{T}$都有$A(\mathcal{T_0}) \ge \mathcal{T}$，我们就说$\mathcal{T_0}$是$P$的 <em>角度最优三角剖分(angle-optimal triangulation)</em>。</p>

<h4 id="way-to-construct-angle-optimal-triangulation">Way to Construct Angle-optimal Triangulation</h4>

<p>如果$P$的三角剖分$\mathcal{T}$中的一条边$e = \overline{p_i p_j}$满足</p>

<ul>
  <li>$e$不是$\mathrm{CH}(\mathcal{S_0})$上的边；</li>
  <li>由$e$构成的两个相邻三角形可以拼接成一个凸四边形，另外两点记为$p_l, p_k$。</li>
</ul>

<p>那么我们可以通过对$\mathcal{T}$删除$\overline{p_ip_j}$并添加$\overline{p_lp_k}$的形式获得不同于$\mathcal{T}$的新的三角剖分$\mathcal{T’}$。显然，两个三角剖分的角度序列中只有6个角发生了变化，它们从$\alpha_1, \alpha_2,\dots, \alpha_6$变成了$\alpha’_1, \alpha’_2,\dots, \alpha’_6$。如果</p>

\[\min_{1\le i \le 6} \alpha_i &lt; \min_{1\le j \le 6} \alpha'_j\]

<p>我们就称边$e = \overline{p_ip_j}$是 <em>不合规的(illegal)</em>。之前提到的“删除$\overline{p_ip_j}$并添加$\overline{p_lp_k}$”操作我们称为 <em>边翻转(edge flip)</em></p>

<p>如果一个三角剖分中不存在不合规边，那么我们就说它是 <em>合规三角剖分(legal triangulation)</em>。根据这些定义，我们可以得知角度最优三角剖分一定是合规三角剖分。</p>

<p>由于有限点集的三角剖分数量是有限的，加上不合规边可以通过边翻转操作变为合规边，因此我们可以通过不断地检查当前三角剖分是否存在不合规边，并通过边翻转操作改进，最终得到一个合规的三角剖分。具体算法如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Algorithm</span> <span class="nf">Legal_Triangulation</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="c1">// Input: Any triangulation T of a point set P</span>
<span class="c1">// Output: A legal triangulation of P</span>
    <span class="k">while</span><span class="p">(</span><span class="n">T</span> <span class="n">contains</span> <span class="n">an</span> <span class="n">illegal</span> <span class="n">edge</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">for</span><span class="p">(</span><span class="n">each</span> <span class="n">edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="n">is</span> <span class="n">illegal</span><span class="p">)</span>
            <span class="n">flip</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">p_i</span><span class="p">,</span> <span class="n">p_j</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">T</span>
</code></pre></div></div>

<p>事实上，基于泰勒斯定理（见附录）及初等几何的知识，我们不需要对重复比较边翻转前后的六个角大小来判断边是否合规，这可以加速算法的过程。但是即便如此，算法的时间复杂度仍然非常大且难以估计；此外，这一方法的结果是合规的三角剖分，与我们最初问题中期待的角度最优三角剖分仍有一定差距。为了解决上述问题，人们提出了 <em>Delaunay三角剖分</em></p>

<h3 id="the-delaunay-triangulation">The Delaunay Triangulation</h3>

<p>在介绍Delaunay三角剖分之前，我们先介绍Voronoi图的对偶图——Delaunay图。</p>

<h4 id="delaunay-graph">Delaunay Graph</h4>

<p>回顾第七章的内容，对于平面上包含$n$个点的点集$P$，可以生成它的Voronoi图：将平面分为$n$个区域，每个区域包含$P$中的一个点。Voronoi图可以保证在该其划分下，平面上任意一点到$P$中最近的一点即为该区域包含的那个点，对于包含$p\in P$的区域，我们称之为 <em>Voronoi元胞(Voronoi cell)</em>，记作$\mathcal{V}(p)$。</p>

<p>如果对于$P$的Voronoi图，我们考虑构造满足如下条件的图$\mathcal{G}$：</p>

<ul>
  <li>$\mathcal{G}$的每个顶点对应一个Voronoi元胞；</li>
  <li>如果两个相邻的Voronoi元胞共享Voronoi图中的一条边，那么$\mathcal{G}$就有一条连接对应这两个元胞顶点的边。</li>
</ul>

<p>如果这样定义的$\mathcal{G}$中，每条边都是直线段，我们就称其为嵌入$P$中的 <em>Delaunay 图</em>，记为$\mathcal{DG}(P)$。</p>

<h4 id="delaunay-triangulation">Delaunay Triangulation</h4>

<p>借助Delaunay图，我们可以得到$P$的合规的，并且在一定条件下也是角度最优的三角剖分。Delaunay图具有如下几条性质。</p>

<ul>
  <li>平面点集的Delaunay图是平面图（证明见附录）</li>
  <li>如果Voronoi图中，$k$条边相交于同一顶点（或者说这个顶点的度数是$k$），那么对应元胞中包含的$P$中的点$p_1, p_2, \dots, p_k$，共圆，进而在Delaunay图中构成一个$k$边形（证明在第七章）</li>
</ul>

<p>由此我们可以将Delaunay分为两种情况，第一种情况为一般情况，此时所有Voronoi图中顶点的度数都是3，则此时Delaunay图$\mathcal{DG}(P)$即为$P$的一个三角剖分；第二种情况下，存在Voronoi图中度数大于3的顶点，则此时我们需要通过继续添加边，来将Delaunay图转化为三角剖分。</p>

<p>由此，对于通过对Delaunay图添加边得到的三角剖分，我们将其称为 <em>Delaunay 三角剖分(Delaunay Triangulation)</em>。</p>

<p>由于Delaunay图中的多边形都是凸的，因此通过添加边获得Delaunay三角剖分简单；此外，对于一般情况，由于$\mathcal{DG}(P)$是三角剖分，此时的Delaunay三角剖分也是唯一的。</p>

<p>我们重新从Delaunay图的角度来叙述第七章中定理7.4的内容：</p>

<p><strong>Theorem 9.6</strong> 令$P$是平面上的点集。</p>

<ul>
  <li>$P$上的三个点$p_i, p_j, p_k$为$\mathcal{DG}(P)$中同一个多边形的顶点当且仅当$p_i, p_j, p_k$三点同在的圆中不包含$P$上的其它点；</li>
  <li>$\overline{p_ip_j}$是$\mathcal{DG}(P)$的边当且仅当存在一个圆盘$C_{ij}$，$p_i, p_j$在其边界上，且其它$P$上的点不在圆盘上。</li>
</ul>

<p>定理9.6隐含了Delaunay三角剖分的如下性质：</p>

<p><strong>Theorem 9.7</strong> 令$P$是平面上的点集，$\mathcal{T}$是$P$的一个三角剖分。则$\mathcal{T}$是$P$的Delaunay三角剖分当且仅当它的任一三角形的外接圆内不包含$P$中的其它点。</p>

<h4 id="the-legality-of-delaunay-triangulation">The Legality of Delaunay Triangulation</h4>

<p>接下来我们讨论Delaunay三角剖分在合规性方面的优越。</p>

<p><strong>Theorem 9.8</strong> 令$P$是平面上的点集。$P$的一个三角剖分$\mathcal{T}$是Delaunay三角剖分当且仅当它是合规的。（证明见附录）</p>

<p>由于任意角度最优的三角剖分必然是合规的，因此定理9.8说明任意角度最优三角剖分也是Delaunay三角剖分。对于一般情况，由于只存在一个Delaunay三角剖分，故合规的三角剖分也只有一个，其自然就是唯一的角度最优三角剖分，于是我们借助Delaunay三角剖分将三角剖分的合规性和角度最优联系起来。</p>

<p>对于特殊情况，即存在$P$中超过3点共圆，且圆中不包含$P$中其它点，此时$P$的Delaunay三角剖分仍然都是合规的，但是并不都是角度最优的。但是我们仍然能够得到一个相对好的结论：这些三角剖分的角度序列中，最小的角度是相同的，即最小的角度与Delaunay图生成Delaunay三角剖分的方式无关。</p>

<p>上述结论可以总结为如下定理，通过泰勒斯定理即初等几何知识可以证明：</p>

<p><strong>Theorem 9.9</strong> 令$P$是平面上的点集。$P$的任意一个角度最优三角剖分都是Delaunay三角剖分。进一步地，任意$P$的Delaunay三角剖分的角度序列中，最小的角度大于等于$P$的任意一个三角剖分的角度序列中最小的角度。</p>

<h3 id="computing-the-delaunay-triangulation">Computing the Delaunay Triangulation</h3>

<p>通过第7章构造Voronoi图的形式，我们可以简单获得$\mathcal{DG}(P)$，之后通过对图中构造大于3的多边形进行合规的三角剖分便可以得到Delaunay三角剖分。本章将介绍一个不借助Voronoi图的方法：我们将通过 <em>随机增量法(Randomized incremental approach)</em> 直接构造Delaunay三角剖分。我们已经在第四章和第六章中采取过一样的方法。</p>

<h4 id="the-idea-of-algorithm">The Idea of Algorithm</h4>

<ol>
  <li>通过向$P$中添加额外两个点，与$P$中纵坐标最大的点构成可以包围其余点的三角形；</li>
  <li>以该三角形为基础剖分，每次向其中添加一个$P$中的点形成新剖分，并且通过维护保持剖分的合规性；</li>
  <li>在所有点添加完毕后，撤除额外的两个点及其它与之有连接的边。</li>
</ol>

<h4 id="algorithm-delaunaytriangulation">Algorithm DelaunayTriangulation</h4>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">Algorithm:</span> <span class="n">DelaunayTriangulation</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="cm">/***
Input: A set P of n+1 points in the plane
Output: A Delaunay triangulation of P
***/</span>

    <span class="c1">//Initialization</span>
    <span class="n">Shuffle</span> <span class="n">P</span><span class="p">,</span> <span class="n">and</span> <span class="n">let</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">be</span> <span class="n">the</span> <span class="n">lexicographically</span> <span class="n">highest</span> <span class="n">point</span> <span class="n">of</span> <span class="n">P</span> 
    <span class="c1">// That is, the rightmost among the points with largest y-coordinate</span>
<span class="mi">2</span>   <span class="n">Let</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="n">and</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="n">be</span> <span class="n">two</span> <span class="n">point</span> <span class="n">in</span> <span class="n">the</span> <span class="n">plane</span> <span class="n">sufficiently</span> <span class="n">far</span> <span class="n">away</span> 
    <span class="c1">// Such that P is contained in the triangle tri(P[0], P[-1], P[-2])</span>
    <span class="n">T</span> <span class="o">&lt;-</span> <span class="n">tri</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">n</span>                       <span class="c1">// Insert P[r] into P per loop</span>

<span class="mi">1</span>       <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>       <span class="c1">// Find a triangle containing P[r]</span>

        <span class="k">if</span> <span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="n">is</span> <span class="n">in</span> <span class="nf">tri</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="c1">// Split tri(P[i], P[j], P[k]) into three triangles</span>
            <span class="n">T</span> <span class="o">&lt;-</span> <span class="n">tri</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="n">T</span> <span class="o">&lt;-</span> <span class="n">tri</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="n">T</span> <span class="o">&lt;-</span> <span class="n">tri</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="n">remove</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">tri</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>

            <span class="c1">// Legalization new edges</span>
            <span class="n">LegalizeEdge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">T</span><span class="p">);</span>
            <span class="n">LegalizeEdge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span> <span class="n">T</span><span class="p">);</span>
            <span class="n">LegalizeEdge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">T</span><span class="p">);</span>

        <span class="k">else</span>    <span class="c1">// P[r] lies on an edge of tri(T[i], T[j], T[k])</span>

            <span class="c1">// Assume that P[r] lies on edge(P[i], P[j]) and P[l] be</span>
            <span class="c1">// the third vertex of the other triangle containing edge(P[i], P[j])</span>

            <span class="c1">// Split tri(P[i], P[j], P[k]) into four triangles</span>
            <span class="n">T</span> <span class="o">&lt;-</span> <span class="n">tri</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="n">T</span> <span class="o">&lt;-</span> <span class="n">tri</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="n">T</span> <span class="o">&lt;-</span> <span class="n">tri</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="n">T</span> <span class="o">&lt;-</span> <span class="n">tri</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="n">remove</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">tri</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
            <span class="n">remove</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">tri</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]))</span>

            <span class="c1">// Legalization new edges</span>
            <span class="n">LegalizeEdge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]),</span> <span class="n">T</span><span class="p">);</span>
            <span class="n">LegalizeEdge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span> <span class="n">T</span><span class="p">);</span>
            <span class="n">LegalizeEdge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]),</span> <span class="n">T</span><span class="p">);</span>
            <span class="n">LegalizeEdge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span> <span class="n">T</span><span class="p">);</span>
                
    <span class="n">Discard</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="n">and</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="n">and</span> <span class="n">associated</span> <span class="n">edges</span> <span class="n">from</span> <span class="n">T</span> 

    <span class="k">return</span> <span class="n">T</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LegalizeEdge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">T</span><span class="p">)</span>
<span class="c1">// The point being inserted is P[r], and edge(P[i], P[j]) is the edge </span>
<span class="c1">// of T that may need to be flipped</span>
    <span class="k">if</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">is</span> <span class="n">illegal</span>
        <span class="c1">// Assume that tri(P[i], P[j], P[k]) be the other triangle</span>
        <span class="c1">// containing edge(P[i], P[j])</span>
        <span class="n">Replace</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">with</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>  <span class="c1">// Edge flip</span>
        <span class="n">LegalizeEdge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">LegalizeEdge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">edge</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span> <span class="n">T</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="algorithm-detail-1-is-the-algorithm-correct">Algorithm Detail 1: Is The Algorithm Correct?</h4>

<p>为了说明算法的正确性（可以通过其生成Delaunay三角剖分），首先介绍如下引理：</p>

<p>Lemma 9.10 对于插入$P[r]$的循环，算法DelaunayTriangulation()与LegalizeEdge()添加的新边都在点集${P[-2], P[-1], P[0],\dots, P[r]}$生成的Delaunay图中。（证明见附录）</p>

<p>借助这个引理，我们可以很轻松地利用数学归纳法证明算法的正确性：插入$P[r]$后，如果一条边$e$是不合规的，那么说明$e$必然在一个以$P[r]$为顶点的三角形中（否则$e$在插入$P[r]$之前就是不合规的）。且每个通过DelaunayTriangulation()或LegalizeEdge()得到的新三角形，其中未经确认的边都会被执行LegalizeEdge()，这样就保证了所有不合规的边都会通过边翻转操作转为合规边，算法的正确性也就被证明了。</p>

<h4 id="algorithm-detail-2-how-to-find-tripi-pj-pk-containing-pr">Algorithm Detail 2: How to find tri(P[i], P[j], P[k]) containing P[r]?</h4>

<blockquote>
  <p>对应主算法伪代码中标记1的位置</p>
</blockquote>

<p>这里我们用了类似第六章中的处理办法：设计一个额外的类似树的结构$\mathcal{D}$，其中每个节点为一个三角形，整体上$\mathcal{D}$一个有向无环图，并且保证$\mathcal{D}$的所有叶子节点对应当前状态下三角剖分的所有最小单位三角形，通过交叉链接实现$\mathcal{D}$与$\mathcal{T}$在基本单位上的一一映射。当向$\mathcal{T}$中添加新的点$P[r]$时，借助$\mathcal{D}$，我们就可以用一种类似于二分的方法进行搜索，快速确定$P[r]$所在的最小单位三角形。由于在算法执行过程中三角剖分始终在发生改变，下面我们详细介绍一下应当如何维护$\mathcal{D}$：</p>

<p>添加新节点时：在插入$P[r]$时，我们会遇到两种情况：</p>

<ul>
  <li>第一种情况是点$P[r]$落在三角形$tri(P[i], P[j], P[k])$中，这种情况下我们需要将$tri(P[i], P[j], P[k])$分为三个新的三角形；</li>
  <li>第二种情况，是点$P[r]$落在三角形$tri(P[i], P[j], P[k])$的边上，则此时我们需要将$tri(P[i], P[j], P[k])$分为两个新的三角形。</li>
</ul>

<p>对于这两种情况，我们都只需要在原本$\mathcal{D}$对应到$tri(P[i], P[j], P[k])$的叶子结点下新添加2或3个子节点，对应新添加的三角形即可。</p>

<p>除了原有的三角形分裂，对于边翻转操作，因为其本质上是重新对一个凸四边形重新作划分，所以当进行边翻转操作时，我们只需要将原有的两个组成凸四边形的叶子节点，指向由两个新的三角形生成的节点，从而实现维护$\mathcal{D}$的目的。</p>

<h4 id="algorithm-detail-3-how-to-choose-p-1-and-p-2-appropriately">Algorithm Detail 3: How to choose P[-1] and P[-2] appropriately?</h4>

<blockquote>
  <p>对应主算法伪代码中标记2的位置</p>
</blockquote>

<p>由于我们在算法中对于$P[-1]$和$P[-2]$有如下两点限制：</p>

<ul>
  <li>$P[-1]$和$P[-2]$应当与$P$保持充分远的距离，从而保证引入它们并不破坏计算Delaunay三角剖分；</li>
  <li>$P[-1]$和$P[-2]$不能距离$P$过于远，否则不仅加大计算难度，还可能会引入不必要的误差。</li>
</ul>

<p>整体审视算法流程，我们发现涉及到$P[-1]$和$P[-2]$的计算过程有两个，第一个是判断新插入的点是否处在三角形中，第二个是判断边是否合规。由于上述两个限制，对于不同的点集$P$定义不同的$P[-1]$和$P[-2]$比较困难。我们将通过对$P[-1]$和$P[-2]$的定义上添加额外条件，使得整个流程中不需要给出$P[-1]$和$P[-2]$的具体值，当上面两个计算过程涉及到$P[-1]$和$P[-2]$时采取其他等价条件代替，从而在满足限制的同时完成需要的计算过程。</p>

<p>在添加额外的条件之前，需要定义平面上如下字典序关系：平面上定义两点$p = (x_p, y_p), q = (x_q, y_q), p \ne q$，我们定义$p&gt;q$当且仅当$y_p &gt; y_q$或者$y_p = y_q, x_p &gt; x_q$。</p>

<p>有了字典序之后，我们可以借助$P$来定义$P[-1], P[-2]$（注意：虽然$P$上现在有了字典序，但是算法流程中是 <strong>不需要进行预先排序的</strong>）</p>

<ol>
  <li>令$l_{-1}$是低于$P$的一条水平直线，$P[-1]$位于$l_{-1}$上，满足（当$P[-1]$的$x$轴坐标足够大，$y$轴坐标足够小时能实现）
    <ol>
      <li>$P[-1]$在$P$上任意非共线三点定义的圆外；</li>
      <li>$P[-1]$从$x$轴正方向开始，顺时针扫描$P$集，其扫过点的顺序同$P$集按字典序升序得到的顺序相同。</li>
    </ol>
  </li>
  <li>令$l_{-2}$是高于$P$的一条水平直线，$P[-2]$位于$l_{-2}$上，满足（当$P[-2]$的$x$轴坐标足够小，$y$轴坐标足够大时能实现）
    <ol>
      <li>$P[-2]$在$P\cup {P[-1]}$上任意非共线三点定义的圆外；</li>
      <li>$P[-2]$从$x$轴正方向开始，逆时针扫描$P$集，其扫过点的顺序同$P$集按字典序升序得到的顺序相同。</li>
    </ol>
  </li>
</ol>

<p>通过这样的 <em>形式化定义</em>$P[-1]$和$P[-2]$，我们可以发现：$P\cup {P[-1], P[-2]}$的Delaunay三角剖分比$P$的Delaunay三角剖分多了如下三类边：</p>

<ul>
  <li>$P[-1]$与$P$的凸包右侧点的连线；</li>
  <li>$P[-2]$与$P$的凸包左侧点的连线；</li>
  <li>$edge(P[-1], P[-2])$。</li>
</ul>

<p>这里的“凸包左侧”和“凸包右侧”是以凸包中字典序最大与字典序最小的两点为划分的左右部分。</p>

<p>现在我们可以解决前面提到的两个计算过程中遇到$P[-1]$和$P[-2]$的情况：</p>

<p>对于第一个计算过程，判断点和三角形的关系，实际上就是判断点与边的位置关系。在我们之前的设置，如下条件是相互等价的：</p>

<ol>
  <li>$P[j]$在$P[i]$和$P[-1]$连线的左侧；</li>
  <li>$P[j]$在$P[-2]$和$P[i]$连线的左侧；</li>
  <li>按字典序$P[j]$比$P[i]$大。</li>
</ol>

<p>利用第三个等价条件，我们就可以解决点与边的位置关系。</p>

<p>对于第二个计算过程，判断边是否合规，由于涉及多种情况，整理后如下：</p>

<p>令$edge(P[i], P[j])$为待判断的边，$P[k]$和$P[l]$为与之共同组成三角形的其它顶点（如果存在），</p>

<ol>
  <li>如果$edge(P[i], P[j])$是三角形$tri(P[0], P[-1], P[-2])$的一条边，那么这条边始终是合规的；</li>
  <li>如果$i, j, k, l$四个角标都是非负的，此时为一般情形，边$edge(P[i], P[j])$不合规当且仅当$P[l]$落在$P[i], P[j]$和$P[k]$三点定义的圆内。</li>
  <li>其它所有情况，$edge(P[i], P[j])$合规当且仅当$\min(k, l) &lt; \min(i, j)$</li>
</ol>

<p>对于第3种情况，其正确性证明见附录。到此我们完全解决了算法中剩下的细节问题。</p>

<h3 id="the-analysis">The Analysis</h3>

<p>在本节中，我们规定$P$的Delaunay三角剖分唯一，即为一般情况的$P$（非一般情况的分析详见书中9.5节）。</p>

<p>开始分析前，我们做如下记号约定：$P_r := {P[1], P[2], \dots, P[r]},\ \mathcal{DG}_r := \mathcal{DG}({P[-2], P[-1], P[0]}\cup P_r)$</p>

<h4 id="analysis-1-structural-change-generated-by-the-algorithm">Analysis 1: Structural Change Generated by the Algorithm</h4>

<p>首先我们分析Delaunay三角剖分的 <em>结构性变化</em>，即整个算法进行流程中，发生的三角形产生和删除总次数。</p>

<p><strong>Lemma 9.11</strong> 算法DelaunayTriangulation产生的三角形数量期望最多为$9n+1$。（证明见附录）</p>

<p>因此整个算法的进行过程中，产生与删除的三角形总数的期望为$O(n)$（删除的三角形数量不可能超过产生的三角形数量）。基于此结果，我们可以对算法的时间和空间复杂度进行分析。</p>

<h4 id="analysis-2-space-complexity">Analysis 2 Space Complexity</h4>

<p><strong>Theorem 9.12.i</strong> 平面点集$P$包含$n$个点，则其Delaunay三角剖分的空间复杂度的期望为$O(n)$。</p>

<p>证明：由引理9.11，产生的三角形数量的期望是$O(n)$，因此只需要考虑$\mathcal{D}$的内存开销。但是因为我们对$\mathcal{D}$和$\mathcal{T}$进行了交叉链接，$\mathcal{D}$中的每个节点均与$\mathcal{T}$中产生和删除的三角形相对应，因此$\mathcal{D}$的内存开销也是$O(n)$。</p>

<h4 id="analysis-3-time-complexity">Analysis 3 Time Complexity</h4>

<p><strong>Theorem 9.12.ii</strong> 平面点集$P$包含$n$个点，其Delaunay三角剖分时间复杂度的期望为$O(n\log n)$。</p>

<p>我们通过分别计算算法中不同操作的时间开销和来得到定理中的结论。算法中涉及到的可能为非线性时间开销的有两部分，第一部分是判断$P[r]$所在三角形；第二部分是产生三角形（因为每产生一个新的三角形，都对应一次LegalizeEdge()操作）。</p>

<p>对于第二部分，因为前面我们证明了产生的新三角形数量的期望是$O(n)$的，因此其时间开销的期望也是线性的。</p>

<p>接下面只剩下判断在$n$次循环中判断新插入的点所在三角形位置需要查找的三角形所花费的时间总和。</p>

<p>由于我们有额外定义的数据结构$\mathcal{D}$，从根节点$tri(P[0], P[-1]， P[-2])$出发，不断搜索子结构，最后便可以确定$P[r]$的位置。因此，对于$P[r]$，确定其位置的时间开销为对当前三角剖分的三角形判断位置花费$O(1)$的常数时间与$O(1)$乘在$\mathcal{D}$中访问的节点数量。</p>

<p>反过来对于每个三角形来说，如果一个三角形不再是$\mathcal{D}$中的子节点，则说明它已经从三角剖分中被删除，而被删除的原因总是因为新加入的$P[r]$在其外接圆内。因此，我们可以将“确定$P[r]$过程中一个三角形的节点被访问”以“这个三角形因为$P[r]$的插入而被删除”而替代。我们记一个三角形$\triangle$的外接圆与$P$的交集为$K(\triangle)$，通过上面的分析，我们知道一个三角形$\triangle$对应到$\mathcal{D}$中的节点，最多只会被$K(\triangle)$中的每个点访问一次，因此判断点位置的操作所花费的时间总和为
\(O(n+ \sum_{\triangle}\mathrm{card}(K(\triangle))),\)
其中的$\triangle$取遍所有算法产生的Delaunay三角形。</p>

<p>接下来我们将证明从期望的角度，$\mathrm{card}(K(\triangle)) = O(n\log n)$（见附录中引理9.13），于是我们就证明了原结论：含有$n$个点的平面点集$P$，其Delaunay三角剖分时间复杂度的期望为$O(n\log n)$。</p>

<h3 id="appendix-the-proof-of-theorems">Appendix: The Proof of Theorems</h3>

<h4 id="theorem-92-泰勒斯定理thaless-theorem">Theorem 9.2 泰勒斯定理(Thales’s Theorem)</h4>

<p>Theorem 9.2 (Thales’s Theorem): 令$C$为一个圆，$l$为与$C$相交的一条直线，两个交点分别为$a, b$。$p, q, r, s$在$l$的同一侧。假设$p, q$在$C$上，$r$在圆内，$s$在圆外，则</p>

\[\angle arb &gt; \angle apb = \angle aqb &gt; \angle asb\]

<blockquote>
  <p>注： 这里书上194页给的叙述有误，该定理并不能保证a, r, b组成的最小的角符合上述要求，而是必须是以r为顶点的角，对于其他三个角也是如此。</p>
</blockquote>

<h4 id="theorem-95">Theorem 9.5</h4>

<p>Theorem 9.5 平面点集的Delaunay图是平面图</p>

<p>证明：要证明这一点，需要借助第七章定理7.4的内容。用Delaunay图的形式重新叙述如下：</p>

<blockquote>
  <p>$\overline{p_ip_j}$是Delaunay图$\mathcal{DG}(P)$的边，当且仅当存在一个圆盘$C_{ij}$，使得$p_i, p_j$在其边缘上，并且其他$P$上的点不在圆盘上（此时$C_{ij}$的圆心在$\mathcal{V}(p_i)$和$\mathcal{V}(p_j)$的共同边上）。</p>
</blockquote>

<p>定义$t_{ij}$为顶点为$p_i, p_j$以及$C_{ij}$的圆心的三角形，注意到$t_{ij}$中连接$p_i$和$C_{ij}$的圆心的边在$\mathcal{V}(p_i)$中，对于$p_j$也有相同的结果。根据之前的假设，这两个边不会同其他$\mathcal{DG}(P)$中的边相交，因此我们只需要考虑$\overline{p_ip_j}$。</p>

<p>假设现在存在$\mathcal{DG}(P)$中的另外一条边$\overline{p_kp_l}$，其与$\overline{p_ip_j}$相交。同之前一样，我们也定义相同的圆$C_{kl}$和三角形$t_{kl}$。根据假设，$p_k, p_l$在圆$C_{ij}$外，必然也在$t_{ij}$外。故$\overline{p_kp_l}$必然还会与$C_{ij}$的圆心和$p_i$或$p_j$的连线之一相交；同样地，$\overline{p_ip_j}$也还会与$C_{kl}$的圆心和$p_k$或$p_l$的连线之一相交。由此可以推出$C_{ij}$的圆心和$p_i$或$p_j$的连线之一会和$C_{kl}$的圆心和$p_k$或$p_l$的连线之一相交，但这些边分别包含在不同的Voronoi元胞中矛盾。</p>

<h4 id="theorem-98">Theorem 9.8</h4>

<p>Theorem 9.8 令$P$是平面上的点集。$P$的一个三角剖分$\mathcal{T}$是Delaunay三角剖分当且仅当它是合规的。</p>

<p>证明：通过定理9.2及定理9.7，易得Delaunay三角剖分是合规的。下面利用反证法说明任意合规的三角剖分是Delaunay三角剖分。</p>

<p>假设一个合规的三角剖分$\mathcal{T}$不是Delaunay三角剖分。根据定理9.6，这说明$\mathcal{T}$中存在一个三角形$tri(P[i], P[j], P[k])$，其外接圆中包含了$P$中的点$P[l]$。记$e = edge(P[i], P[j])$为将$P[k]$与$P[l]$分隔的那条边。现在我们假设$\mathcal{T}$中能够使$\angle P[i]P[l]P[j]$最大的一组点为$(P[i] P[j] P[k], P[l])$。</p>

<p>由于$\mathcal{T}$是合规的三角剖分，因此存在$P[m]$，使得$tri(P[i], P[j], P[m])\in \mathcal{T}$是$tri(P[i], P[j], P[k])$相邻的三角形。按合规性的要求，$P[m]$不在$tri(P[i], P[j], P[k])$的外接圆内。</p>

<p>因为$P[m]$和$P[l]$在$e$的同一侧，所以$P[l]$必然在$tri(P[i], P[j], P[m])$的外接圆内。此时假设$edge(P[j], P[m])$为将$P[i]$与$P[l]$分隔的那条边。但是此时$\angle P[m]P[l]P[j] &gt; \angle P[i]P[l]P[j]$与之前的假设产生矛盾。</p>

<p>所以合规的三角剖分也是Delaunay三角剖分。</p>

<h4 id="lemma-910">Lemma 9.10</h4>

<p>Lemma 9.10 LegalizeEdge()添加的新边都在点集${P[-2], P[-1], P[0],\dots, P[r]}$生成的Delaunay图中。</p>

<p>证明：分两种类型的边考虑：</p>

<p>第一种类型，此时的边为开始分裂原有三角形产生的，假设原有的三角形为$tri(P[i], P[j], P[k])$，由于其之前为Delaunay三角剖分中的三角形，因此满足定理9.6的空圆性质，即三角形$tri(P[i], P[j], P[k])$的外接圆$C$，使得任何满足$t &lt; r$的点$P[t]$不在其内。在添加$P[r]$后，对于新产生的边$edge(P[i], P[r])$（对于$j, k$有相同结论），当我们收缩$C$并且保持$P[i]$始终在$C$上的时候，总能得到一个圆$C’$通过$P[r]$，此时$P[j], P[k]$也不在$C’$中，因此满足了空圆性质的第二类性质，即$edge(P[i], P[j])$是新Delaunay图中的一条边；</p>

<p>第二类是通过边翻转操作得到的新的边，假设原本的三角形为$tri(P[i], P[j], P[r])$和$tri(P[i], P[j], P[l])$，现在的边翻转操作是删除边$edge(P[i], P[j])$，添加边$edge(P[r], P[l])$，现在我们只需要证明$edge(P[r], P[l])$满足空圆性质。类似之前的证明，存在三角形$tri(P[i], P[j], P[l])$的外接圆$C$，使得任何满足$t &lt; r$的点$P[t]$不在其内。由于需要边翻转操作，$P[r]$必然处在$C$内。现在收缩$C$并且保持$P[l]$始终在$C$上的时候，总能得到一个圆$C’$通过$P[r]$，此时$P[i], P[j]$也不在$C’$中，因此满足了边的空圆性质，因此$edge(P[r], P[l])$是新Delaunay图中的一条边。</p>

<h4 id="边合规判断的第3种情况正确性证明">边合规判断的第3种情况正确性证明</h4>

<p>因为当$i = -1, j = -2$的情况已经被纳入第1种情况了，因此$i$和$j$中至多有一个是负的。另一方面，因为边翻转操作需要处理的边为$edge(P[k], P[l])$，而这条边的一个顶点为$P[r]$，因此$k$和$l$中也至多有一个是负的。</p>

<p>如果四个角标中只有一个是负的，那么按对于$P[-1]$和$P[-2]$的定义，这个角标为负数的点必然在其他三个点的外接圆之外，这种情况下这个方法是正确的（如果负数是$k$或$l$中的一个，则$edge(P[i], P[j])$是合规的，否则如果$i$或$j$中一个为负数，则$edge(P[k], P[l])$是合规的）。</p>

<p>如果$\min(i, j)$和$\min(k, j)$都是负的，那么根据我们前面的定义，$P[-2]$在$P\cup {P[-1]}$中任意非共线三个点的外接圆之外，因此这个方法仍然是正确的（如果-2是$k$或$l$中的一个，则$edge(P[i], P[j])$是合规的，否则如果$i$或$j$中一个为-2，则$edge(P[k], P[l])$是合规的）。</p>

<p>于是我们就证明了第3种情况下边翻转操作的正确性。</p>

<h4 id="lemma-911">Lemma 9.11</h4>

<p>Lemma 9.11 算法DelaunayTriangulation产生的三角形数量期望最多为$9n+1$。</p>

<p>证明：证明过程与算法伪代码一一对应。</p>

<ol>
  <li>算法开始部分，产生了一个三角形$tri(P[0], P[-1], P[-2])$。</li>
  <li>考虑算法进行到第$r$次循环时的情况：
    <ol>
      <li>如果在插入$P[r]$之后，$\mathcal{DG}_r$中有$k$条边的顶点包含$P[r]$(即$P[r]$的度数为$k$)，则最多将产生$2k-3$个新的三角形，这是因为插入$P[r]$最多产生3个三角形，此时$k = 3$，每进行一次边翻转操作将会产生2个新的三角形，$k$都会增长$1$；</li>
      <li>根据定理7.3，$\mathcal{DG}_r$最多包含$3(r+3)-6$条边，由于其中有3条是$tri(P[0], P[-1], P[-2])$的边，因此$P_r$中所有点的度数和小于$2[3(r+3)-9] = 6r$，则$P[r]$中每个点的度数期望最大为6；</li>
      <li>因此第$r$次循环产生的新三角形期望$E_r \le E[2\deg(P[r], \mathcal{DG}_r) - 3] = 2E[\deg(P[r], \mathcal{DG}_r)] - 3 \le 9$。</li>
    </ol>
  </li>
  <li>总结1和2，算法产生三角形的数量期望最多为$9n+1$。</li>
</ol>

<h4 id="lemma-913">Lemma 9.13</h4>

<p>Lemma 9.13 如果$P$是常规情况下含有$n$个点的平面点集，于是</p>

\[\mathrm{card}(K(\triangle)) = O(n\log n)\]

<p>其中$\triangle$取遍算法中产生的Delaunay三角形。</p>

<p>证明：由于$P$为常规情况，因此每个$P_r$也是常规情况，故$\mathcal{DG}<em>r$都是唯一的。定义$\mathcal{DG}_r$中的三角形为$\mathcal{T}_r$，因此在第$r$次循环中产生的三角形为$\mathcal{T}_r\backslash\mathcal{T}</em>{r-1}$。用这个定义，我们可以重新将和写作</p>

\[\mathrm{card}(K(\triangle)) = \sum_{r = 1}^{n}\left(\sum_{\triangle\in \mathcal{T}_r\backslash\mathcal{T}_{r-1}}\mathrm{card}(K(\triangle))\right)\]

<p>除此之外，我们定义$k(P_r, q)$为全部$\triangle\in\mathcal{T}<em>r$中满足点$q\in\triangle$的三角形数量；定义$k(P_r, q, P[r])$为全部$\triangle\in\mathcal{T}_r$中不仅满足点$q\in\triangle$，同时还有一个顶点为$P[r]$的三角形数量。由于$\mathcal{T}_r\backslash\mathcal{T}</em>{r-1}$中的每个三角形都必然有一个顶点为$P[r]$，所以我们可以再做一次转化：</p>

\[\sum_{\triangle\in \mathcal{T}_r\backslash\mathcal{T}_{r-1}}\mathrm{card}(K(\triangle))
    =
    \sum_{q\in P\backslash P_r}k(P_r, q, P[r])\]

<p>到此我们先将$P_r$固定，所谓固定，就是我们考虑所有$P$的重排中满足$P_r = P_r^<em>$的情况。那么$k(P_r, q, P[r])$仅依赖于$P[r]$的选取。因为一个三角形$\triangle\in\mathcal{T}_r$的顶点为$p\in P_r^</em>$的的概率最高为$3/r$，因此</p>

\[E[k(P_r, q, P[r])] \le \frac{3k(P_r, q)}{r}\]

<p>将这个期望代入前面的累加和，就有</p>

\[E\left[\sum_{\triangle\in \mathcal{T}_r\backslash\mathcal{T}_{r-1}}\mathrm{card}(K(\triangle))\right]
    \le
    \frac{3}{r}\sum_{q\in P\backslash P_r}k(P_r, q).\]

<p>又因为每个$q\in P\backslash P_r$都可以视作做$P[r+1]$，因此</p>

\[E[k(P_r, P[r+1])] = \frac{1}{n-r}\sum_{q\in P\backslash P_r}k(P_r, q)\]

<p>再次代入累加和的结果，就有</p>

\[E\left[\sum_{\triangle\in \mathcal{T}_r\backslash\mathcal{T}_{r-1}}\mathrm{card}(K(\triangle))\right]
    \le
    3\left(\frac{n-r}{r}\right)E[k(P_r, P[r+1])].\]

<p>按开始的定义，$k(P_r, P[r+1])$是指所有$\triangle\in \mathcal{T_r}$中满足$P[r+1]\in K(\triangle)$的数量。然而根据Delaunay三角剖分的算法，这些三角形刚好是在第$r+1$次循环中被删除的三角形，这样，我们就可以重写不等式为</p>

\[E\left[\sum_{\triangle\in \mathcal{T}_r\backslash\mathcal{T}_{r-1}}\mathrm{card}(K(\triangle))\right]
    \le
    3\left(\frac{n-r}{r}\right)E[\mathrm{card}(\mathcal{T}_r\backslash\mathcal{T}_{r+1})]\]

<p>对于凸包顶点数固定（该算法中始终为3）的情况，$\mathcal{T}_m$中包含的三角形数量是$2(m+3)-2-3 = 2m+1$个。因此在第$r+1$次循环后，新删除的三角形数量比新产生的三角形数量少2，这样又可以重写不等式为</p>

\[E\left[\sum_{\triangle\in \mathcal{T}_r\backslash\mathcal{T}_{r-1}}\mathrm{card}(K(\triangle))\right]
    \le
    3\left(\frac{n-r}{r}\right)\left(E[\mathrm{card}(\mathcal{T}_{r+1}\backslash\mathcal{T}_{r})] - 2\right).\]

<p>到此为止，我们都固定了$P_r = P_r^*$。接下来我们将所有可能的$P_r\subset P$应用到不等式两侧后取平均，发现对于$P$的任意重排，上述不等式都是成立的。</p>

<p>在之前的证明中，我们证明过两件事，第一件事是插入$P[r+1]$后所有新产生的三角形的数量与由$P[r+1]$组成的边的数量相同；第二件事是每个顶点的度数期望最大为6。总结起来，不等式可以重写为</p>

\[E\left[\sum_{\triangle\in \mathcal{T}_r\backslash\mathcal{T}_{r-1}}\mathrm{card}(K(\triangle))\right]
    \le
    12\left(\frac{n-r}{r}\right).\]

<p>再对两边从$r = 1$累加到$r = n$，便得到我们想要的结果：</p>

\[\mathrm{card}(K(\triangle)) = O(n\log n).\]]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="learning" /><category term="Computational Geometry" /><summary type="html"><![CDATA[Chapter 09 Delaunay Triangulations]]></summary></entry><entry><title type="html">6.046_notes_01</title><link href="http://localhost:4000/2023/01/14/6_046_notes_01/" rel="alternate" type="text/html" title="6.046_notes_01" /><published>2023-01-14T23:44:00+08:00</published><updated>2023-01-14T23:44:00+08:00</updated><id>http://localhost:4000/2023/01/14/6_046_notes_01</id><content type="html" xml:base="http://localhost:4000/2023/01/14/6_046_notes_01/"><![CDATA[<blockquote>
  <p>6.046: Design and Analysis of Algorithms</p>

  <p>笔记01：</p>
</blockquote>

<h2 id="lesson-01-introduction--overview">Lesson 01: Introduction &amp; Overview</h2>

<ul>
  <li>课程概览</li>
  <li>不同算法的复杂度</li>
  <li>问题1：区间调度问题</li>
</ul>

<h3 id="课程概览">课程概览</h3>

<ul>
  <li>Divide and Conquer - FFT and randomization algorithms</li>
  <li>Optimization: greedy and dynamic programming</li>
  <li>Network flow</li>
  <li>Intractability (and dealing with it)</li>
  <li>Linear programming</li>
  <li>Sublinear algorithms, approximation algorithms</li>
  <li>Advanced topics</li>
</ul>

<h3 id="相似的问题可能有不同的复杂度">相似的问题可能有不同的复杂度</h3>

<p>定义hard：如果解决问题A可以转化为解决问题B的方法来解决，那么可以认为B的复杂度是比A的复杂度高，我们就说A问题可以约化为B问题，或者说A不比B难。</p>

<ul>
  <li>P问题：在多项式时间可以得出答案的问题，即$O(n^k)$存在某个常数$k$</li>
  <li>NP问题：在多项式时间内能够被验证答案是否正确的问题</li>
  <li>NP-complete问题：和其他NP问题一样难的NP问题</li>
</ul>

<h3 id="问题1区间调度问题">问题1：区间调度问题</h3>

<p>对$n$段单独的区间资源$1, 2, \dots, n$进行请求。记$s(i), f(i)$分别为每个区间资源的开始时间和结束之间，我们约定$s(i) &lt; f(i)$。如果两段区间资源$i, j$的所处区间没有重叠,即满足$f(i) \le s(j)$或$f(j) \le s(i)$，我们就称这两段区间资源是 <strong>兼容的(compatible)</strong> 。</p>

<p>Definition of <strong>Interval Scheduling Problem</strong> :</p>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Input: $n$ requests with ${s(i), f(i)</td>
          <td>i = 1 , 2 , \dots , n}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Goal: a <strong>compatible</strong> subset of ${1,2, \dots, n}$ of maximum size</li>
  <li>Method: <strong>Select a greedy algorithm</strong></li>
</ul>

<h3 id="贪心法求解区间调度问题">贪心法求解区间调度问题</h3>

<h4 id="贪心法设计求解步骤">贪心法设计求解步骤</h4>

<ol>
  <li>按一个 <strong>规则</strong> 选取请求$i$;</li>
  <li>拒绝所有与$i$不兼容的请求；</li>
  <li>对剩下的请求，重复步骤1和2，直到所有请求都被处理。</li>
</ol>

<h4 id="如何选取合适的规则">如何选取合适的规则？</h4>

<p>可以选取的规则：</p>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />选取开始时间$s(i)$最早的请求 -&gt; 反例：当区间长度最长的请求开始时间最早</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />选取区间长度$f(i) - s(i)$最短的的请求 -&gt; 反例：两个接续进行的请求和一个与它们都不兼容的更短的请求</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />选取和其它请求不兼容数量最少的请求 -&gt; 反例：更多开始与结束时间相同的请求，会使得规则同设想情况不同</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />选取结束时间$f(i)$最早的请求</li>
</ul>

<p>通过如下两个命题证明最后一种规则是正确的规则：</p>

<ol>
  <li>
    <p>命题1（兼容性条件）：满足要求的子集，可以通过重新排列，表示为
\((s(i_1), f(i_1)), (s(i_2), f(i_2)), \dots, (s(i_k), f(i_k))\)
其中
\(s(i_1) &lt; f(i_1) \le s(i_2) &lt; f(i_2) \le \dots \le s(i_k) &lt; f(i_k)\)</p>
  </li>
  <li>
    <p>命题2：按命题1的排列，不存在与请求$i_r$和$i_{r+1}$兼容的请求$j$，使得
\(f(i_r) \le s(j), f(j) \le s(i_{r+1})\)
同时满足（对$r = 1$和$r + 1 = k$，则其中有意义的一个不等式不满足）</p>
  </li>
</ol>

<p>由上述两个命题，便可以证明“选取最早结束请求”这个规则的正确性。</p>

<h4 id="算法时间复杂度">算法时间复杂度</h4>

<p>该方法需要做一步对所有请求的结束时间排序的预处理，所需时间为$O(n\log n)$；接下来便是按序执行步骤，处理所有请求，所需时间为$O(n)$。因此算法的时间复杂度为$O(n \log n)$。</p>

<h4 id="对于贪心法的总结">对于贪心法的总结</h4>

<ul>
  <li>贪心法是一种非常 <strong>“短视”</strong> 的策略，它更看重当前情况，实现最近一步可以实现最优结果；</li>
  <li>由于贪心法的理念，如何能够通过人为设定的规则，实现当前状况得到最优解是该方法最困难的部分，而且对于很多问题，证明规则的正确性同样是一件很困难的事情；</li>
  <li>此外，由于贪心法总是考虑一步最优解的“不回头策略”，因此通过该策略解决问题不一定总能找到最优解；</li>
  <li>但是由于贪心法的高效性，这种策略应用于对于最优解要求并不严格的问题时效果比较理想，并可以作为辅助算法，结合其他策略共同解决问题。</li>
</ul>

<h3 id="加权区间调度问题和更多更改">加权区间调度问题和更多更改</h3>

<h4 id="加权区间调度问题">加权区间调度问题</h4>

<p>如果我们将问题改为 <strong>加权区间调度</strong> ，即对每段区间资源都添加一个与区间长度无关的权值$w(i)$，并将问题目标改为 <strong>求得权值相加最大的兼容请求子集</strong>。</p>

<p>此时一种可以求解的方法是 <strong>动态规划(Dynamic Programming)</strong>：</p>

<ul>
  <li>定义子问题$opt(R^{x})$为请求集$R$中开始时间大于$x$的子集的兼容请求权值相加最大值；</li>
  <li>当请求$i$纳入考虑的时候，则此时$x$应为$f(i)$，且$opt(R^x)$应当加上$w(i)$；</li>
  <li>子问题的总数为$n$，基本情况$opt(R^{f(n)}) = 0$</li>
  <li>由此可以按关系式$opt(R) = \max_{1 \le i \le n}(w(i) + opt(R^{f(i)}))$求解目标问题</li>
</ul>

<p>通过动态规划，加权区间调度问题的时间复杂度也可以达到$O(n \log n)$，<strong>但是按之前规则再次进行贪心策略的结果就会产生错误</strong>。</p>

<h4 id="进一步修改问题设定">进一步修改问题设定</h4>

<p>假设现在有$m$台处理请求的机器$\tau = {T_1, T_2,\dots, T_m}$，对于每个请求$i$，仅有子集$Q(i)\subseteq \tau$包含的机器可以处理该请求。如果每个请求的权值都是1:</p>

<ol>
  <li>问题 <strong>$m$台机器能够处理的请求最大数量</strong> 是 <strong>NP问题</strong>；</li>
  <li>问题 <strong>判断$k \le n$个请求能否被兼容执行</strong> 是 <strong>NP完全问题</strong>；</li>
  <li>问题 <strong>$m$台机器能够兼容处理的请求最大数量</strong> 是 <strong>NP难问题</strong>。</li>
</ol>

<h3 id="解决复杂问题intractability的方法">解决复杂问题(intractability)的方法</h3>

<ul>
  <li>采用近似的算法：可以提供多项式时间的优化；</li>
  <li>利用启发式算法来减少实际算例的时间；</li>
  <li>贪心或者其他实际应用有效的次优化启发式，但是无法保证效果。</li>
</ul>

<h2 id="lesson-02-divide-and-conquer">Lesson 02: Divide and Conquer</h2>

<ul>
  <li>时间复杂度的计算范式</li>
  <li>问题2：凸包问题</li>
  <li>问题3：确定中位数问题</li>
</ul>

<h3 id="分治法的算法范式">分治法的算法范式</h3>

<p>给定一个规模为$n$的问题，将其分解为$a$个规模为$\frac{n}{b}$的子问题，其中$a\ge 1, b \ge 1$。递归解决每个子问题，将子问题的结果组合在一起，得到原始问题的结果。</p>

<p>时间花费满足如下关系式：</p>

\[T(n) = aT(\frac{n}{b}) + [\mathrm{work\ for\ merge}]\]

<h3 id="问题2凸包问题">问题2：凸包问题</h3>

<h4 id="问题描述">问题描述</h4>

<p>给定平面上的$n$个点</p>

\[S = \{(x_i, y_i)|i = 1,2,\dots, n\}\]

<p>并假设不存在两个具有相同$x$坐标或者$y$坐标的点，并且不存在共线的3个点。</p>

<p><strong>凸包</strong> (Convex Hull, CH($S$)): 能够包含$S$中所有点的最小多边形。</p>

<p>易知，CH($S$)的顶点即为$S$中的点，而且我们用顺时针顺序的点列来表示CH($S$)。</p>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Input: point set $S = {(x_i, y_i)</td>
          <td>i = 1,2,\dots, n}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Goal: CH($S$) = ${p_1, p_2, \dots, p_k}$</li>
  <li>Method: <strong>Divide and Conquer</strong></li>
</ul>

<h4 id="暴力法计算凸包">暴力法计算凸包</h4>

<p>思路：通过判断$S$中任意两点的连线是否能将其余点分为两部分，来确定这两点的连线是否是凸包的一部分。</p>

<p>时间复杂度：$O(n^2)$条边，每条边进行$O(n)$次检测 -&gt; 故复杂度为$O(n^3)$</p>

<h4 id="利用分治法计算凸包">利用分治法计算凸包</h4>

<p>利用分治的思想计算凸包，首先需要进行预处理：对$S$中的所有点按$x$坐标进行排序：$O(n\log n)$</p>

<p>预处理后，按如下步骤求解CH($S$)：</p>

<ul>
  <li>将$S$按$x$坐标排序，分为左半部分$A$和右半部分$B$；</li>
  <li>计算CH($A$)和CH($B$);</li>
  <li>CH($S$) = merge(CH($A$), CH($B$)).</li>
</ul>

<h4 id="how-to-merge">How to merge?</h4>

<p>由于$A$和$B$是$S$的左半部分和右半部分，因此两个子凸包是彼此不相交的，所以通过结合子凸包CH($A$)和CH($B$)的点列，便可以得到CH($S$)。</p>

<p>假设$a_1$是CH($A$) $= (a_1, a_2,\dots, a_p)$中$x$坐标最大的点，$b_1$是CH($B$) $= (b_1, b_2,\dots, b_q)$中$x$坐标最小的点。$L$是$A$和$B$中间的一条垂直于$x$轴的直线，定义$y(i, j)$是$L$与线段$(a_i,b_j)$的交点纵坐标的值。</p>

<table>
  <tbody>
    <tr>
      <td>按如上定义，我们能够得知：CH($S$)与$L$有且只有两个交点，且上交点的值是$Y = {y(i, j)</td>
      <td>i = 1,2\dots, p;j = 1,2,\dots, q}$的最大值，下交点的值是$Y$的最小值。$L$左侧部分CH($S$)的点是CH($A$)的点，$L$右侧部分CH($S$)的点是CH($B$)的点。只要能够得知对应组成上交点的线段与下交点的线段，便可以完成Merge()操作。</td>
    </tr>
  </tbody>
</table>

<p>Algorithm(类似于double-finger的操作) for get uppertangent:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
    <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">||</span> <span class="n">y</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>   
                <span class="n">j</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>      <span class="c1">// Move right finger clockwise</span>
            <span class="k">if</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>  <span class="c1">// Move left finger anti-clockwise</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a_i</span><span class="p">,</span> <span class="n">b_j</span><span class="p">);</span>
</code></pre></div></div>

<p>对于求下交点是同理的。</p>

<h4 id="时间复杂度">时间复杂度：</h4>

<p>利用主定理，可以简单算出</p>

\[T(n) = 2T(\frac{n}{2}) + \Theta(n) = \Theta(n \log n)\]

<p>再加上预处理的的排序需要$O(n\log n)$的时间，利用分治法计算凸包的总时间复杂度为$\Theta(n\log n)$。</p>

<h3 id="问题3确定中位数问题">问题3：确定中位数问题</h3>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="Learning Notes" /><category term="“6.046”" /><summary type="html"><![CDATA[6.046: Design and Analysis of Algorithms 笔记01：]]></summary></entry><entry><title type="html">GAMES101_notes_02</title><link href="http://localhost:4000/2023/01/14/GAMES101_notes_02/" rel="alternate" type="text/html" title="GAMES101_notes_02" /><published>2023-01-14T23:44:00+08:00</published><updated>2023-01-14T23:44:00+08:00</updated><id>http://localhost:4000/2023/01/14/GAMES101_notes_02</id><content type="html" xml:base="http://localhost:4000/2023/01/14/GAMES101_notes_02/"><![CDATA[<blockquote>
  <p>GAMES101: 现代计算机图形学入门</p>

  <p>笔记02：Shading</p>
</blockquote>

<h2 id="lesson-07-shading-1illumination-shading-and-graphics-pipeline">Lesson 07 Shading 1(Illumination, Shading and Graphics Pipeline)</h2>

<p>本讲内容：</p>

<ul>
  <li>Visibility/ occlusion
    <ul>
      <li>Z-buffering</li>
    </ul>
  </li>
  <li>Shading
    <ul>
      <li>Illumination &amp; Shading</li>
      <li>Graphics Pipeline</li>
    </ul>
  </li>
</ul>

<h3 id="visibility-可见性">Visibility 可见性</h3>

<h4 id="painters-algorithm">Painter’s Algorithm</h4>

<p>受油画绘画技术的启发，作画时应当先画远处的物体，再画近处的物体，从而保证物体遮挡的结果是正确的</p>

<p>问题是如何判断哪个物体远，哪个物体近？相同远近的物体，绘画顺序怎么样确定？</p>

<p>需要首先对三角形进行排序，需要$O(n\log n)$的时间，但是不能完全解决问题</p>

<h3 id="z-buffer-深度缓存">Z-buffer 深度缓存</h3>

<p>用于解决上述提到的问题</p>

<p>Idea:</p>

<ul>
  <li>Store current min. z-value <strong>for each sample(pixel)</strong></li>
  <li>Needs an additional buffer for depth values
    <ul>
      <li>frame buffer stores color values</li>
      <li>depth buffer (z-buffer) stores depth</li>
    </ul>
  </li>
</ul>

<p>Important: For simplicity we suppose $z$ is always positive(smaller $z$ -&gt; closer, larger $z$ -&gt; further)</p>

<h4 id="算法流程">算法流程</h4>

<ul>
  <li>Initialize depth buffer to $\infty$</li>
  <li>During rasterization:</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="p">(</span><span class="n">each</span> <span class="n">triangle</span> <span class="n">T</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="n">each</span> <span class="n">sample</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="n">in</span> <span class="n">T</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">zbuffer</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>           <span class="c1">// closest sample so far</span>
                <span class="n">framebuffer</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgb</span><span class="p">;</span>    <span class="c1">// update color</span>
                <span class="n">zbuffer</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>          <span class="c1">// update depth</span>
            <span class="k">else</span>
                <span class="p">;</span>                           <span class="c1">// do nothing, this sample is occluded</span>
</code></pre></div></div>

<p>（目前只是说明在已知深度的情况下如何处理遮挡关系，还未介绍如何确定物体深度）</p>

<h4 id="正确性和复杂度">正确性和复杂度</h4>

<p>复杂度</p>

<ul>
  <li>对于$n$个三角形只需要花费$O(n)$的时间</li>
  <li>并不是排序算法，所以时间消耗是线性的</li>
</ul>

<p>不同三角形处理顺序不改变结果(但是会被舍入误差影响)</p>

<p>Most important visibility algorithm</p>

<ul>
  <li>Implemented in hardware for all GPUs</li>
</ul>

<h4 id="对于msaa的影响">对于MSAA的影响</h4>

<p>当采用MSAA时，深度缓存应当是对每个采样点，而不是对每个像素进行采样</p>

<h2 id="shading-着色">Shading 着色</h2>

<p>目前已经学过的内容：</p>

<ul>
  <li>Position objects and the camera in the world 空间中的模型和摄像机</li>
  <li>Compute position of objects relative to the camera 计算模型位置</li>
  <li>Project objects onto the screen 投影</li>
  <li>Sample triangle coverage 光栅化</li>
</ul>

<p>下一步的操作：着色（Shading）</p>

<h3 id="definition-of-shading">Definition of Shading</h3>

<ul>
  <li>The definition in the dictionary: The darkening or coloring of an illustration or diagram with parallel lines or a block of color.</li>
  <li>The definition in this course: The process of applying a material to an object.</li>
</ul>

<h3 id="a-simple-shading-modelblinn-phong-reflectance-model">A Simple Shading Model(Blinn-Phong Reflectance Model)</h3>

<h4 id="perceptual-observations">Perceptual Observations</h4>

<ul>
  <li>Specular highlights 高光</li>
  <li>Diffuse reflection 漫反射</li>
  <li>Ambient lighting 环境光照</li>
</ul>

<h4 id="shading-is-local">Shading is Local</h4>

<p>Compute light reflected toward camera at specific <strong>shading point</strong></p>

<p>Input:</p>

<ul>
  <li>Viewer direction, $v$</li>
  <li>Surface normal, $n$</li>
  <li>Light direction(for each of many lights), $l$</li>
  <li>Surfaces parameters(colors, shininess, …)</li>
</ul>

<p>注意：着色并不是添加阴影！（shading $\ne$ shadow）</p>

<h4 id="diffuse-reflection">Diffuse Reflection</h4>

<ul>
  <li>Light is scattered uniformly in all directions
    <ul>
      <li>Surface color is the same for all viewing directions</li>
    </ul>
  </li>
  <li>But how much light(energy) is received?
    <ul>
      <li>Lambert’s cosine law：随着光线和平面法线夹角$\theta$的不断扩大，单位面积接收到的光线能量逐渐变小，比例满足$\cos \theta = l \cdot n$</li>
    </ul>
  </li>
</ul>

<h4 id="light-falloff-能量耗散">Light Falloff 能量耗散</h4>

<p>将光源视为一个持续释放能量的点，则随着传播距离的增加，能量的大小应当与距离的平方成反比。</p>

<h4 id="lambertiandiffuse-shading">Lambertian(Diffuse) Shading</h4>

<p>Shading <strong>independent</strong> of view direction</p>

\[L_d = k_d(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{l})\]

<p>其中</p>

<ul>
  <li>$L_d$: diffusely reflected light</li>
  <li>$k_d$: diffuse coefficient (color)</li>
  <li>$(I/r^2)$: energy arrived at the shading point</li>
  <li>$\max(0, \mathbf{n}\cdot \mathbf{l})$: energy received by the shading point</li>
</ul>

<h2 id="lesson-08-shading-2shading-pipeline-and-texture-mapping">Lesson 08 Shading 2(Shading, Pipeline and Texture Mapping)</h2>

<p>本讲内容：</p>

<ul>
  <li>Blinn-Phong reflectance model
    <ul>
      <li>Specular and ambient terms</li>
    </ul>
  </li>
  <li>Shading frequencies</li>
  <li>Graphics pipeline</li>
  <li>Texture mapping</li>
</ul>

<h3 id="blinn-phong-reflectance-model">Blinn-Phong reflectance model</h3>

<p>回忆上讲的漫反射项(Lambertian/Diffuse Term)，可以发现漫反射项和观测方向$v$没有关系，对任意方向的反射光强度都是相同的。</p>

<h4 id="specular-termblinn-phong">Specular Term(Blinn-Phong)</h4>

<p>Intensity <strong>depends</strong> on view direction</p>

<ul>
  <li>Bright near mirror reflection direction</li>
</ul>

<p>$v$ close to mirror direction $\Leftrightarrow$ <strong>half vector near normal</strong></p>

<ul>
  <li>Measure “near” by dot product of unit vectors</li>
</ul>

<p>引入半程向量$\mathbf{h}$，可以避免计算反射向量$r$的困难，半程向量的计算公式如下：</p>

\[\begin{align*}
    \mathbf{h}
    &amp;= bisector(\mathbf{v}, \mathbf{l})\\
    &amp;= \frac{\mathbf{v}+\mathbf{l}}{\|\mathbf{v}+\mathbf{v}\|}
\end{align*}\]

<p>则Blinn-Phong公式给出的镜面反射项为</p>

\[\begin{align*}
    L_s
    &amp;= k_s(I/r^2)\max(0, \cos \alpha)^p\\
    &amp;= k_s(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{h})^p
\end{align*}\]

<p>其中</p>

<ul>
  <li>$L_s$: Specularly reflected light</li>
  <li>$k_s$: specular coefficient</li>
  <li>余弦值添加指数参数$p$的原因：能够使高光得到加窄，使得只有最接近镜面反射的部分高光明显。一般$p$取$100-200$</li>
</ul>

<h4 id="ambient-termblinn-phong">Ambient Term(Blinn-Phong)</h4>

<p>Shading that does not depend on anything</p>

<ul>
  <li>Add constant color to account for disregarded illumination and fill in black shadows</li>
  <li>This is approximate / fake!</li>
</ul>

<p>环境光项计算公式如下：</p>

\[L_a = k_a I_a\]

<p>其中</p>

<ul>
  <li>$L_a$: Reflected ambient light</li>
  <li>$k_a$: Ambient coefficient</li>
</ul>

<p>综合上述内容，可得到Blinn-Phong反射模型：</p>

\[\begin{align*}
    L &amp;= L_a + L_d + L_s\\
    &amp;= k_aI_a + k_d(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{l}) + k_s(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{h})^p
\end{align*}\]

<h3 id="shading-frequencies-着色频率">Shading Frequencies 着色频率</h3>

<p>对每个平面上多少个点进行Shading，将会影响着色的结果</p>

<p>三种常见的着色方式：</p>

<ol>
  <li><strong>Flat</strong> Shading 逐面着色
    <ul>
      <li>Triangle face is flat - one normal vector</li>
      <li>Not good for smooth surfaces</li>
    </ul>
  </li>
  <li><strong>Gouraud</strong> shading 逐顶点着色
    <ul>
      <li>Interpolate colors from vertices across triangle</li>
      <li>Each vertex has a normal vector(how?)</li>
    </ul>
  </li>
  <li><strong>Phong</strong> shading 逐像素着色
    <ul>
      <li>Interpolate normal vectors across each triangle</li>
      <li>Compute full shading model at each pixel</li>
      <li>Not the Blinn-Phong Reflectance Model</li>
    </ul>
  </li>
</ol>

<p>当几何体足够复杂的时候，逐面着色和逐顶点着色与逐像素着色的区别会变小。</p>

<h4 id="define-per-vertex-normal-vectors">Define Per-Vertex Normal Vectors</h4>

<p>Best to get vertex normals from the underlying geometry. Otherwise have to infer vertex normal from triangle faces</p>

<ul>
  <li>Simple scheme: <strong>Average surrounding face normals</strong></li>
</ul>

\[N_v = \frac{\sum_i N_i}{\|\sum_iN_i\|}\]

<h4 id="define-per-pixel-normal-vectors">Define Per-Pixel Normal Vectors</h4>

<p>Barycentric interpolation (introducing soon) of vertex normals.</p>

<p>Don’t forget to normalize the interpolated directions</p>

<h3 id="graphicsreal-time-rendering-pipeline">Graphics(Real-time Rendering) Pipeline</h3>

<p>管线：从Input到Output的过程：</p>

<ul>
  <li>Input: Vertices in 3D space</li>
  <li>Application:
    <ol>
      <li>Vertex Processing: Vertices positioned in screen space</li>
      <li>Triangle Processing: Triangles positioned in screen space</li>
      <li>Rasterization: Fragments(one per covered sample)</li>
      <li>Fragment Processing: Shaded fragments</li>
      <li>Framebuffer Operations: Display</li>
    </ol>
  </li>
  <li>Output: images(pixels)</li>
</ul>

<p>过去学习的内容对应到pipeline中：</p>

<ul>
  <li>MVP transforms: 1</li>
  <li>Sampling triangle coverage: 3</li>
  <li>Z-Buffer Visibility Tests: 4</li>
  <li>Shading: 1, 4(考虑不同的着色频率，着色发生的环节会不同)</li>
  <li>Texture mapping(introducing soon): 1, 4</li>
</ul>

<h4 id="shader-programs">Shader Programs</h4>

<ul>
  <li>Program vertex and fragment processing stages(分别称为vertex-shader和fragment-shader/pixel-shader)</li>
  <li>Describe operation on a single vertex(or fragment)</li>
</ul>

<p>Example GLSL fragment shader program</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">my</span> <span class="n">Texture</span><span class="p">;</span> <span class="c1">// program parameter</span>
<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightDir</span><span class="p">;</span>        <span class="c1">// program parameter</span>
<span class="n">varying</span> <span class="n">vec2</span> <span class="n">uv</span><span class="p">;</span>              <span class="c1">// per fragment value(interp. by rasterizer)</span>
<span class="n">varying</span> <span class="n">vec3</span> <span class="n">norm</span><span class="p">;</span>            <span class="c1">// per fragment value(interp. by rasterizer)</span>

<span class="kt">void</span><span class="p">(</span><span class="n">diffuseShader</span><span class="p">)()</span>
<span class="p">{</span>
  <span class="n">vec3</span> <span class="n">kd</span><span class="p">;</span>
  <span class="n">kd</span> <span class="o">=</span> <span class="n">texture2d</span><span class="p">(</span><span class="n">myTexture</span><span class="p">,</span> <span class="n">uv</span><span class="p">);</span>                <span class="c1">// material color from texture</span>
  <span class="n">kd</span> <span class="o">*=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">norm</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  <span class="c1">// Lambertian shading model</span>
  <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">kd</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>                 <span class="c1">// Output fragment color</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Remark:</p>

<ul>
  <li>Shader function executes once per fragment;</li>
  <li>Outputs color of surface at the current fragment’s screen sample position;</li>
  <li>This shader performs a texture lookup to obtain the surfaces’s material color at this point, then performs a diffuse lighting calculation.</li>
</ul>

<p><a href="https://shadertoy.com/view/ld3Gz2">Snail Shader Program</a></p>

<h4 id="modern-development-in-cg">Modern development in CG</h4>

<p>（省略该部分内容）</p>

<h3 id="texture-mapping">Texture Mapping</h3>

<p>本质：在物体不同位置定义不同属性</p>

<h4 id="surfaces-are-2d">Surfaces are 2D</h4>

<p>Surface lives in 3D world space. Every 3D surface point also has a place where it goes in the 2D image(texture).</p>

<p>需要考虑物体平面和纹理空间的映射关系，纹理空间坐标系通过$u-v$坐标系表示，通过映射关系可以实现从$[0,1]^2$纹理空间到物体表面的映射</p>

<h4 id="textures-can-be-used-multiple-times">Textures can be used multiple times</h4>

<p>通过设计纹理图样，可以实现同样纹理贴图的无缝衔接</p>

<h4 id="interpolation-across-triangles-barycentric-coordinatesnext-lesson">Interpolation Across Triangles: Barycentric Coordinates(next lesson)</h4>

<h2 id="lesson-09-shading-3texture-mapping-cont">Lesson 09 Shading 3(Texture Mapping Cont.)</h2>

<p>本讲内容：</p>

<ul>
  <li>Barycentric coordinates 重心坐标</li>
  <li>Texture queries 添加纹理的流程</li>
  <li>Applications of textures 纹理相关应用</li>
</ul>

<h3 id="interpolation-across-triangles-barycentric-coordinates">Interpolation Across Triangles: Barycentric Coordinates</h3>

<p>为什么要进行插值？</p>

<ul>
  <li>在每个顶点定义固定值</li>
  <li>我们希望能够在三角形中每点上平滑获得合适的值</li>
</ul>

<p>对哪些内容进行插值？</p>

<ul>
  <li>Texture coordinates, colors, normal vector, …</li>
</ul>

<p>怎么做插值？</p>

<ul>
  <li>Barycentric Coordinates</li>
</ul>

<h3 id="barycentric-coordinates">Barycentric Coordinates</h3>

<p>三角形所在平面中的任一点，都可以用顶点坐标的线性组合来表示：</p>

\[\mathbf{x} = \alpha A + \beta B + \gamma C\]

<p>其中三个系数需要满足</p>

\[\alpha + \beta + \gamma = 1\]

<p>如果还满足$\alpha, \beta, \gamma \ge 0$，那么该点一定在三角形内。我们称$(\alpha, \beta, \gamma)$为该点关于三角形$ABC$的 <strong>重心坐标</strong>。</p>

<p>由上述定义，可知$A, B, C$三点的重心坐标分别是$(1,0,0), (0,1,0), (0,0,1)$；对于三角形内任意一点$\mathbf{X}$其重心坐标的三个分量$\alpha, \beta, \gamma$可以由如下公式得到：</p>

\[\alpha = \frac{S_{\triangle XBC}}{S_{\triangle ABC}},\quad
  \beta = \frac{S_{\triangle XCA}}{S_{\triangle ABC}},\quad
  \gamma = \frac{S_{\triangle XAB}}{S_{\triangle ABC}}\]

<p>即三个分量的比等于其对应三个三角形的面积比。</p>

<p>三角形的重心，其重心坐标为$(\frac{1}{3}, \frac{1}{3}, \frac{1}{3})$</p>

<p>对于$x-y$平面上的三角形$ABC$与其中的一点$(x, y)$，利用上述的定义及叉乘的相关知识可以得到其重心坐标分量为</p>

\[\alpha = \frac{-(x - x_B)(y_C - y_B) + (y - y_B)(x_C - x_B)}{-(x_A - x_B)(y_C - y_B) + (y_A - y_B)(x_C - x_B)},\\
  \beta = \frac{-(x - x_C)(y_A - y_C) + (y - y_C)(x_A - x_C)}{-(x_B - x_C)(y_A - y_C) + (y_B - y_C)(x_A - x_C)},\\
  \gamma = 1 - \alpha - \beta.\]

<h4 id="using-barycentric-coordinates">Using Barycentric Coordinates</h4>

<p>当给定三角形顶点的信息，我们就可以通过重心坐标计算得到相应的三角形中对赢点的信息</p>

\[V = \alpha V_A + \beta V_B + \gamma V_C\]

<p><strong>However, barycentric coordinates are not invariant under projection!</strong></p>

<h3 id="applying-textures">Applying Textures</h3>

<h4 id="simple-texture-mapping-diffuse-color">Simple Texture Mapping: Diffuse Color</h4>

<ul>
  <li>For each rasterized screen sample $(x, y)$:</li>
  <li>$(u, v)$ = evaluate texture coordinate at $(x, y)$(using barycentric coordinates)</li>
  <li>texcolor = texture.sample $(u, v)$;</li>
  <li>set sample’s color to texcolor;</li>
</ul>

<h4 id="texture-magnificationeasy-case">Texture Magnification(easy case)</h4>

<p>当像素数量大于纹理贴图元素数量的时候，需要采用双线性插值（Bilinear Interpolation），来避免小纹理贴到大图上的时候过于失真的情况。</p>

<p>对于一个映射到纹理上坐标非整数的像素点，可以利用与其最近的四个纹理元素进行双线性插值，得到一个结果值</p>

<ul>
  <li>Linear interpolation: $lerp(x, v_0, v_1) = v_0 + x(v_1 - v_0)$</li>
  <li>Two helper lerps:
\(u_0 = lerp(s, u_{00}, u_{10})\\
  u_1 = lerp(s, u_{10}, u_{11})\)</li>
  <li>Final vertical lerp, to get result: $f(x, y) = lerp(t, u_0, u_1)$</li>
</ul>

<p>进一步，可以采取更高精度的多项式插值（双向三次样条插值）</p>

<h4 id="texture-magnificationhard-case">Texture Magnification(hard case)</h4>

<p>当纹理贴图元素数量大于像素数量的时候，结果会比之前更糟糕（走样：摩尔纹和锯齿）</p>

<p>如果此时用超采样，那么可以对抗走样问题，得到很好的结果，但是花费过于昂贵了。</p>

<p>为了能够保证采样频率满足纹理的频率，除了增加采样的频率以外，也可以通过处理纹理频率（即降低纹理频率）的方法来解决问题。</p>

<h4 id="mipmap-allowingfast-approx-square-range-queries">Mipmap: Allowing(fast, approx., square) range queries</h4>

<p>通过将纹理不停取平均，每次将纹理分辨率降低1/4，得到一个 <strong>纹理金字塔</strong>。对于分辨率为$n$的纹理，得到的纹理金字塔的分辨率综合是$\frac{4}{3}n$，即$O(n)$。</p>

<p>通过计算采样点与相邻采样点映射到纹理上的点构成的四边形面积，即可确定应该利用纹理金字塔中哪层的结果进行映射。</p>

<p>但是实际贴图中，如果用离散的层进行贴图，可能导致最后的图像存在纹理的不连续现象，则将实数的层数其上下的整数层，在两个整数层进行双线性插值，得到纹理贴图结果，再根据实际层数进行插值，便可以得到一个相对连续的结果（<strong>三线性插值</strong>）</p>

<p>但是Mipmap只能应用于方形结构，对于一些长宽比不相同的结构，可能会出现过模糊的现象(overblur)。</p>

<h4 id="anisotropic-filtering-各向异性过滤">Anisotropic Filtering 各向异性过滤</h4>

<p>Ripmaps and summed area tables</p>

<ul>
  <li>对于矩形区域查询可以得到很好的结果。</li>
  <li>但是对于沿对角线方向延伸的形状，计算结果仍然很差。</li>
</ul>

<p>效果更加优秀的过滤方法：EWA filtering</p>

<h3 id="application-of-textures第十讲内容">Application of Textures（第十讲内容）</h3>

<p>In modern GPUs, texture = memory + range query(filtering)</p>

<ul>
  <li>General method to bring data to fragment calculations</li>
</ul>

<p>Many applications:</p>

<ul>
  <li>Environment lighting 环境光照（环境贴图）</li>
  <li>Store microgeometry</li>
  <li>Procedural textures</li>
  <li>Solid modeling</li>
  <li>Volume rendering</li>
  <li>…</li>
</ul>]]></content><author><name>zhengtongdu</name><email>zhengtongdu_at_zju.edu.cn</email></author><category term="Learning Notes" /><category term="GAMES101" /><summary type="html"><![CDATA[GAMES101: 现代计算机图形学入门 笔记02：Shading]]></summary></entry></feed>