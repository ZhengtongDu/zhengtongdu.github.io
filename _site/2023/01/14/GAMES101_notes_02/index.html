<!doctype html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/pure-min.css" integrity="sha384-cg6SkqEOCV1NbJoCu11+bm0NvBRc8IYLRGXkmNrqUBfTjmMYwNKPWBTIKyw9mHNJ" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/grids-responsive-min.css">
  <link rel="stylesheet" href="/assets/styles.css"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>GAMES101_notes_02 | Zhengtong’s blog</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="GAMES101_notes_02" />
<meta name="author" content="zhengtongdu" />
<meta property="og:locale" content="en" />
<meta name="description" content="GAMES101: 现代计算机图形学入门 笔记02：Shading," />
<meta property="og:description" content="GAMES101: 现代计算机图形学入门 笔记02：Shading," />
<link rel="canonical" href="http://localhost:4000/2023/01/14/GAMES101_notes_02/" />
<meta property="og:url" content="http://localhost:4000/2023/01/14/GAMES101_notes_02/" />
<meta property="og:site_name" content="Zhengtong’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-01-14T23:44:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="GAMES101_notes_02" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"zhengtongdu","url":"https://github.com/zhengtongdu"},"dateModified":"2023-01-14T23:44:00+08:00","datePublished":"2023-01-14T23:44:00+08:00","description":"GAMES101: 现代计算机图形学入门 笔记02：Shading,","headline":"GAMES101_notes_02","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/01/14/GAMES101_notes_02/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/avapig.jpg"},"name":"zhengtongdu"},"url":"http://localhost:4000/2023/01/14/GAMES101_notes_02/"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Zhengtong's blog" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } });
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
                       });
  </script>

  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  </script>
</head>


  <body>

    <div class="container pure-g"><div class="sidebar-left pure-u-1 pure-u-md-1-4" style="background-color: rgb(40, 73, 77); color: rgb(255, 255, 255); background-image: url(/bg.jpg);"><header class="masthead">
  <div class="avatar"><img src="/avapig.jpg" class="avatar-image" alt="zhengtongdu">
    </div>
  <div class="masthead-title">
    <a href="/" title="Home">Zhengtong's blog</a>
  </div>
  <div class="masthead-tagline">
    <small>learn&record&share</small>
  </div><nav class="navigation">
    <ul class="navigation-list"><li class="navigation-item">
        <a onclick="sessionStorage.setItem('forceCheckScroll', 'true')" href="/">Blog</a>
      </li><li class="navigation-item">
        <a onclick="sessionStorage.setItem('forceCheckScroll', 'true')" href="/about/">About</a>
      </li></ul>
  </nav><div class="social pure-menu pure-menu-horizontal">
      <ul class="social-icons pure-menu-list">
      <li class="pure-menu-item">
          <a class="social-icon pure-menu-link" href="mailto://zhengtongdu@zju.edu.cn">
            <i class="fas fa-envelope" title="Email"></i>
          </a>
        </li><li class="pure-menu-item">
          <a class="social-icon pure-menu-link" href="https://github.com/zhengtongdu">
            <i class="fab fa-github" title="GitHub"></i>
          </a>
        </li>
      </ul>
    </div>
</header>
</div>

      <div class="content pure-u-1 pure-u-md-1-2"><main>
  <article class="post">
  <h1 class="post-title">GAMES101_notes_02</h1>
  <div class="post-meta"><time datetime="2023-01-14T23:44:00+08:00" itemprop="datePublished">14 Jan 2023</time></div>

  <blockquote>
  <p>GAMES101: 现代计算机图形学入门</p>

  <p>笔记02：Shading,</p>
</blockquote>

<h2 id="lesson-07-shading-1illumination-shading-and-graphics-pipeline">Lesson 07 Shading 1(Illumination, Shading and Graphics Pipeline)</h2>

<p>本讲内容：</p>

<ul>
  <li>Visibility/ occlusion
    <ul>
      <li>Z-buffering</li>
    </ul>
  </li>
  <li>Shading
    <ul>
      <li>Illumination &amp; Shading</li>
      <li>Graphics Pipeline</li>
    </ul>
  </li>
</ul>

<h3 id="visibility-可见性">Visibility 可见性</h3>

<h4 id="painters-algorithm">Painter’s Algorithm</h4>

<p>受油画绘画技术的启发，作画时应当先画远处的物体，再画近处的物体，从而保证物体遮挡的结果是正确的</p>

<p>问题是如何判断哪个物体远，哪个物体近？相同远近的物体，绘画顺序怎么样确定？</p>

<p>需要首先对三角形进行排序，需要$O(n\log n)$的时间，但是不能完全解决问题</p>

<h3 id="z-buffer-深度缓存">Z-buffer 深度缓存</h3>

<p>用于解决上述提到的问题</p>

<p>Idea:</p>

<ul>
  <li>Store current min. z-value <strong>for each sample(pixel)</strong></li>
  <li>Needs an additional buffer for depth values
    <ul>
      <li>frame buffer stores color values</li>
      <li>depth buffer (z-buffer) stores depth</li>
    </ul>
  </li>
</ul>

<p>Important: For simplicity we suppose $z$ is always positive(smaller $z$ -&gt; closer, larger $z$ -&gt; further)</p>

<h4 id="算法流程">算法流程</h4>

<ul>
  <li>Initialize depth buffer to $\infty$</li>
  <li>During rasterization:</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="p">(</span><span class="n">each</span> <span class="n">triangle</span> <span class="n">T</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="n">each</span> <span class="n">sample</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="n">in</span> <span class="n">T</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">zbuffer</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>           <span class="c1">// closest sample so far</span>
                <span class="n">framebuffer</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgb</span><span class="p">;</span>    <span class="c1">// update color</span>
                <span class="n">zbuffer</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>          <span class="c1">// update depth</span>
            <span class="k">else</span>
                <span class="p">;</span>                           <span class="c1">// do nothing, this sample is occluded</span>
</code></pre></div></div>

<p>（目前只是说明在已知深度的情况下如何处理遮挡关系，还未介绍如何确定物体深度）</p>

<h4 id="正确性和复杂度">正确性和复杂度</h4>

<p>复杂度</p>

<ul>
  <li>对于$n$个三角形只需要花费$O(n)$的时间</li>
  <li>并不是排序算法，所以时间消耗是线性的</li>
</ul>

<p>不同三角形处理顺序不改变结果(但是会被舍入误差影响)</p>

<p>Most important visibility algorithm</p>

<ul>
  <li>Implemented in hardware for all GPUs</li>
</ul>

<h4 id="对于msaa的影响">对于MSAA的影响</h4>

<p>当采用MSAA时，深度缓存应当是对每个采样点，而不是对每个像素进行采样</p>

<h2 id="shading-着色">Shading 着色</h2>

<p>目前已经学过的内容：</p>

<ul>
  <li>Position objects and the camera in the world 空间中的模型和摄像机</li>
  <li>Compute position of objects relative to the camera 计算模型位置</li>
  <li>Project objects onto the screen 投影</li>
  <li>Sample triangle coverage 光栅化</li>
</ul>

<p>下一步的操作：着色（Shading）</p>

<h3 id="definition-of-shading">Definition of Shading</h3>

<ul>
  <li>The definition in the dictionary: The darkening or coloring of an illustration or diagram with parallel lines or a block of color.</li>
  <li>The definition in this course: The process of applying a material to an object.</li>
</ul>

<h3 id="a-simple-shading-modelblinn-phong-reflectance-model">A Simple Shading Model(Blinn-Phong Reflectance Model)</h3>

<h4 id="perceptual-observations">Perceptual Observations</h4>

<ul>
  <li>Specular highlights 高光</li>
  <li>Diffuse reflection 漫反射</li>
  <li>Ambient lighting 环境光照</li>
</ul>

<h4 id="shading-is-local">Shading is Local</h4>

<p>Compute light reflected toward camera at specific <strong>shading point</strong></p>

<p>Input:</p>

<ul>
  <li>Viewer direction, $v$</li>
  <li>Surface normal, $n$</li>
  <li>Light direction(for each of many lights), $l$</li>
  <li>Surfaces parameters(colors, shininess, …)</li>
</ul>

<p>注意：着色并不是添加阴影！（shading $\ne$ shadow）</p>

<h4 id="diffuse-reflection">Diffuse Reflection</h4>

<ul>
  <li>Light is scattered uniformly in all directions
    <ul>
      <li>Surface color is the same for all viewing directions</li>
    </ul>
  </li>
  <li>But how much light(energy) is received?
    <ul>
      <li>Lambert’s cosine law：随着光线和平面法线夹角$\theta$的不断扩大，单位面积接收到的光线能量逐渐变小，比例满足$\cos \theta = l \cdot n$</li>
    </ul>
  </li>
</ul>

<h4 id="light-falloff-能量耗散">Light Falloff 能量耗散</h4>

<p>将光源视为一个持续释放能量的点，则随着传播距离的增加，能量的大小应当与距离的平方成反比。</p>

<h4 id="lambertiandiffuse-shading">Lambertian(Diffuse) Shading</h4>

<p>Shading <strong>independent</strong> of view direction</p>

\[L_d = k_d(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{l})\]

<p>其中</p>

<ul>
  <li>$L_d$: diffusely reflected light</li>
  <li>$k_d$: diffuse coefficient (color)</li>
  <li>$(I/r^2)$: energy arrived at the shading point</li>
  <li>$\max(0, \mathbf{n}\cdot \mathbf{l})$: energy received by the shading point</li>
</ul>

<h2 id="lesson-08-shading-2shading-pipeline-and-texture-mapping">Lesson 08 Shading 2(Shading, Pipeline and Texture Mapping)</h2>

<p>本讲内容：</p>

<ul>
  <li>Blinn-Phong reflectance model
    <ul>
      <li>Specular and ambient terms</li>
    </ul>
  </li>
  <li>Shading frequencies</li>
  <li>Graphics pipeline</li>
  <li>Texture mapping</li>
</ul>

<h3 id="blinn-phong-reflectance-model">Blinn-Phong reflectance model</h3>

<p>回忆上讲的漫反射项(Lambertian/Diffuse Term)，可以发现漫反射项和观测方向$v$没有关系，对任意方向的反射光强度都是相同的。</p>

<h4 id="specular-termblinn-phong">Specular Term(Blinn-Phong)</h4>

<p>Intensity <strong>depends</strong> on view direction</p>

<ul>
  <li>Bright near mirror reflection direction</li>
</ul>

<p>$v$ close to mirror direction $\Leftrightarrow$ <strong>half vector near normal</strong></p>

<ul>
  <li>Measure “near” by dot product of unit vectors</li>
</ul>

<p>引入半程向量$\mathbf{h}$，可以避免计算反射向量$r$的困难，半程向量的计算公式如下：</p>

\[\begin{align*}
    \mathbf{h}
    &amp;= bisector(\mathbf{v}, \mathbf{l})\\
    &amp;= \frac{\mathbf{v}+\mathbf{l}}{\|\mathbf{v}+\mathbf{v}\|}
\end{align*}\]

<p>则Blinn-Phong公式给出的镜面反射项为</p>

\[\begin{align*}
    L_s
    &amp;= k_s(I/r^2)\max(0, \cos \alpha)^p\\
    &amp;= k_s(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{h})^p
\end{align*}\]

<p>其中</p>

<ul>
  <li>$L_s$: Specularly reflected light</li>
  <li>$k_s$: specular coefficient</li>
  <li>余弦值添加指数参数$p$的原因：能够使高光得到加窄，使得只有最接近镜面反射的部分高光明显。一般$p$取$100-200$</li>
</ul>

<h4 id="ambient-termblinn-phong">Ambient Term(Blinn-Phong)</h4>

<p>Shading that does not depend on anything</p>

<ul>
  <li>Add constant color to account for disregarded illumination and fill in black shadows</li>
  <li>This is approximate / fake!</li>
</ul>

<p>环境光项计算公式如下：</p>

\[L_a = k_a I_a\]

<p>其中</p>

<ul>
  <li>$L_a$: Reflected ambient light</li>
  <li>$k_a$: Ambient coefficient</li>
</ul>

<p>综合上述内容，可得到Blinn-Phong反射模型：</p>

\[\begin{align*}
    L &amp;= L_a + L_d + L_s\\
    &amp;= k_aI_a + k_d(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{l}) + k_s(I/r^2)\max(0, \mathbf{n} \cdot \mathbf{h})^p
\end{align*}\]

<h3 id="shading-frequencies-着色频率">Shading Frequencies 着色频率</h3>

<p>对每个平面上多少个点进行Shading，将会影响着色的结果</p>

<p>三种常见的着色方式：</p>

<ol>
  <li><strong>Flat</strong> Shading 逐面着色
    <ul>
      <li>Triangle face is flat - one normal vector</li>
      <li>Not good for smooth surfaces</li>
    </ul>
  </li>
  <li><strong>Gouraud</strong> shading 逐顶点着色
    <ul>
      <li>Interpolate colors from vertices across triangle</li>
      <li>Each vertex has a normal vector(how?)</li>
    </ul>
  </li>
  <li><strong>Phong</strong> shading 逐像素着色
    <ul>
      <li>Interpolate normal vectors across each triangle</li>
      <li>Compute full shading model at each pixel</li>
      <li>Not the Blinn-Phong Reflectance Model</li>
    </ul>
  </li>
</ol>

<p>当几何体足够复杂的时候，逐面着色和逐顶点着色与逐像素着色的区别会变小。</p>

<h4 id="define-per-vertex-normal-vectors">Define Per-Vertex Normal Vectors</h4>

<p>Best to get vertex normals from the underlying geometry. Otherwise have to infer vertex normal from triangle faces</p>

<ul>
  <li>Simple scheme: <strong>Average surrounding face normals</strong></li>
</ul>

\[N_v = \frac{\sum_i N_i}{\|\sum_iN_i\|}\]

<h4 id="define-per-pixel-normal-vectors">Define Per-Pixel Normal Vectors</h4>

<p>Barycentric interpolation (introducing soon) of vertex normals.</p>

<p>Don’t forget to normalize the interpolated directions</p>

<h3 id="graphicsreal-time-rendering-pipeline">Graphics(Real-time Rendering) Pipeline</h3>

<p>管线：从Input到Output的过程：</p>

<ul>
  <li>Input: Vertices in 3D space</li>
  <li>Application:
    <ol>
      <li>Vertex Processing: Vertices positioned in screen space</li>
      <li>Triangle Processing: Triangles positioned in screen space</li>
      <li>Rasterization: Fragments(one per covered sample)</li>
      <li>Fragment Processing: Shaded fragments</li>
      <li>Framebuffer Operations: Display</li>
    </ol>
  </li>
  <li>Output: images(pixels)</li>
</ul>

<p>过去学习的内容对应到pipeline中：</p>

<ul>
  <li>MVP transforms: 1</li>
  <li>Sampling triangle coverage: 3</li>
  <li>Z-Buffer Visibility Tests: 4</li>
  <li>Shading: 1, 4(考虑不同的着色频率，着色发生的环节会不同)</li>
  <li>Texture mapping(introducing soon): 1, 4</li>
</ul>

<h4 id="shader-programs">Shader Programs</h4>

<ul>
  <li>Program vertex and fragment processing stages(分别称为vertex-shader和fragment-shader/pixel-shader)</li>
  <li>Describe operation on a single vertex(or fragment)</li>
</ul>

<p>Example GLSL fragment shader program</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">my</span> <span class="n">Texture</span><span class="p">;</span> <span class="c1">// program parameter</span>
<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">lightDir</span><span class="p">;</span>        <span class="c1">// program parameter</span>
<span class="n">varying</span> <span class="n">vec2</span> <span class="n">uv</span><span class="p">;</span>              <span class="c1">// per fragment value(interp. by rasterizer)</span>
<span class="n">varying</span> <span class="n">vec3</span> <span class="n">norm</span><span class="p">;</span>            <span class="c1">// per fragment value(interp. by rasterizer)</span>

<span class="kt">void</span><span class="p">(</span><span class="n">diffuseShader</span><span class="p">)()</span>
<span class="p">{</span>
  <span class="n">vec3</span> <span class="n">kd</span><span class="p">;</span>
  <span class="n">kd</span> <span class="o">=</span> <span class="n">texture2d</span><span class="p">(</span><span class="n">myTexture</span><span class="p">,</span> <span class="n">uv</span><span class="p">);</span>                <span class="c1">// material color from texture</span>
  <span class="n">kd</span> <span class="o">*=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">norm</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  <span class="c1">// Lambertian shading model</span>
  <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">kd</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>                 <span class="c1">// Output fragment color</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Remark:</p>

<ul>
  <li>Shader function executes once per fragment;</li>
  <li>Outputs color of surface at the current fragment’s screen sample position;</li>
  <li>This shader performs a texture lookup to obtain the surfaces’s material color at this point, then performs a diffuse lighting calculation.</li>
</ul>

<p><a href="https://shadertoy.com/view/ld3Gz2">Snail Shader Program</a></p>

<h4 id="modern-development-in-cg">Modern development in CG</h4>

<p>（省略该部分内容）</p>

<h3 id="texture-mapping">Texture Mapping</h3>

<p>本质：在物体不同位置定义不同属性</p>

<h4 id="surfaces-are-2d">Surfaces are 2D</h4>

<p>Surface lives in 3D world space. Every 3D surface point also has a place where it goes in the 2D image(texture).</p>

<p>需要考虑物体平面和纹理空间的映射关系，纹理空间坐标系通过$u-v$坐标系表示，通过映射关系可以实现从$[0,1]^2$纹理空间到物体表面的映射</p>

<h4 id="textures-can-be-used-multiple-times">Textures can be used multiple times</h4>

<p>通过设计纹理图样，可以实现同样纹理贴图的无缝衔接</p>

<h4 id="interpolation-across-triangles-barycentric-coordinatesnext-lesson">Interpolation Across Triangles: Barycentric Coordinates(next lesson)</h4>

<h2 id="lesson-09-shading-3texture-mapping-cont">Lesson 09 Shading 3(Texture Mapping Cont.)</h2>

<p>本讲内容：</p>

<ul>
  <li></li>
</ul>


  
    
      <div class="post-tags-section">
  <i class="post-tags-icon fas fa-tags"></i>
  <ul class="post-tags"><li>
        <a class="post-tag" href="/tags/#learning-notes">learning-notes</a></li><li>
        <a class="post-tag" href="/tags/#games101">games101</a></li></ul>
</div>

  

  
</article>


<aside class="related">
  <h2>Related posts</h2>
  <ul class="related-posts">
    
      <li>
        <a href="/2023/01/14/Computational_Geometry_notes_01/">
          Computational_Geometry_notes_01
          <small><time datetime="2023-01-14T23:49:00+08:00">14 Jan 2023</time></small>
        </a>
      </li>
    
      <li>
        <a href="/2023/01/14/6_046_notes_01/">
          6.046_notes_01
          <small><time datetime="2023-01-14T23:44:00+08:00">14 Jan 2023</time></small>
        </a>
      </li>
    
      <li>
        <a href="/2023/01/14/Computational_Geometry_notes_01/">
          Computational_geometry_notes_01
          <small><time datetime="2023-01-14T00:00:00+08:00">14 Jan 2023</time></small>
        </a>
      </li>
    
  </ul>
</aside>


</main>

<footer class="footer"><small>
    &copy; 2022&nbsp;-&nbsp;2023 <a href="https://github.com/zhengtongdu">zhengtongdu</a>. All rights reserved.
    Powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://github.com/vszhub/not-pure-poole">Not Pure Poole</a>.
  </small>
</footer>
</div>
      <div class="sidebar-right pure-u-1 pure-u-md-1-4">
<div  class="toc-wrapper">
  <h2 class="toc-title">Table of Contents</h2>
    <nav class="toc-nav">
      <ul class="toc">
  <li><a href="#lesson-07-shading-1illumination-shading-and-graphics-pipeline">Lesson 07 Shading 1(Illumination, Shading and Graphics Pipeline)</a>
    <ul>
      <li><a href="#visibility-可见性">Visibility 可见性</a></li>
      <li><a href="#z-buffer-深度缓存">Z-buffer 深度缓存</a></li>
    </ul>
  </li>
  <li><a href="#shading-着色">Shading 着色</a>
    <ul>
      <li><a href="#definition-of-shading">Definition of Shading</a></li>
      <li><a href="#a-simple-shading-modelblinn-phong-reflectance-model">A Simple Shading Model(Blinn-Phong Reflectance Model)</a></li>
    </ul>
  </li>
  <li><a href="#lesson-08-shading-2shading-pipeline-and-texture-mapping">Lesson 08 Shading 2(Shading, Pipeline and Texture Mapping)</a>
    <ul>
      <li><a href="#blinn-phong-reflectance-model">Blinn-Phong reflectance model</a></li>
      <li><a href="#shading-frequencies-着色频率">Shading Frequencies 着色频率</a></li>
      <li><a href="#graphicsreal-time-rendering-pipeline">Graphics(Real-time Rendering) Pipeline</a></li>
      <li><a href="#texture-mapping">Texture Mapping</a></li>
    </ul>
  </li>
  <li><a href="#lesson-09-shading-3texture-mapping-cont">Lesson 09 Shading 3(Texture Mapping Cont.)</a></li>
</ul>

  </nav>
</div>

</div>
    </div>

    <script async src="https://use.fontawesome.com/releases/v5.0.12/js/all.js"></script><script>
  function strip(str, remove) {
    while (str.length > 0 && remove.indexOf(str.charAt(0)) != -1) {
      str = str.substr(1);
    }
    while (str.length > 0 && remove.indexOf(str.charAt(str.length - 1)) != -1) {
      str = str.substr(0, str.length - 1);
    }
    return str;
  }

  function scroll() {
    console.log('scroll');
    window.scrollTo({
      left: 0, 
      top: window.innerHeight,
      behavior: 'smooth'
    });
    sessionStorage.removeItem('forceCheckScroll');
  }

  const forceCheckScroll = sessionStorage.getItem('forceCheckScroll') === 'true';
  const checkScroll = strip(window.location.pathname, '/') !== strip('', '/');

  if (forceCheckScroll || checkScroll) {
    const maxWidth = "(max-width: 48rem)";
    const result = window.matchMedia(maxWidth);
    if (result.matches) {
      scroll();
    } else {
      result.addListener((match) => {
        if (match.media == maxWidth) {
          if (match.matches) {
            scroll();
          }
        }
      });
    }
  }
</script>
</body>
</html>
